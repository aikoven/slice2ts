// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generate typings built-in slices 1`] = `
"import { Ice } from \\"ice\\";
import { IceMX } from \\"../Ice/Metrics\\";

declare module \\"../IceMX.ns\\" {
  namespace IceMX {
    /**
     * Provides information on Glacier2 sessions.
     */
    class SessionMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        forwardedClient?: number,
        forwardedServer?: number,
        routingTableSize?: number,
        queuedClient?: number,
        queuedServer?: number,
        overriddenClient?: number,
        overriddenServer?: number
      );

      /**
       * Number of client requests forwared.
       */
      forwardedClient: number;

      /**
       * Number of server requests forwared.
       */
      forwardedServer: number;

      /**
       * The size of the routing table.
       */
      routingTableSize: number;

      /**
       * Number of client requests queued.
       */
      queuedClient: number;

      /**
       * Number of server requests queued.
       */
      queuedServer: number;

      /**
       * Number of client requests overridden.
       */
      overriddenClient: number;

      /**
       * Number of server requests overridden.
       */
      overriddenServer: number;
    }
  }
}
export { IceMX } from \\"../IceMX.ns\\";
"
`;

exports[`generate typings built-in slices 2`] = `
"import { Ice } from \\"ice\\";
import { Glacier2 } from \\"../Glacier2/SSLInfo\\";

declare module \\"./Glacier2.ns\\" {
  namespace Glacier2 {
    /**
     * This exception is raised if a client is denied the ability to create
     * a session with the router.
     */
    class PermissionDeniedException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason why permission was denied.
       */
      reason: string;
    }

    /**
     * The Glacier2 permissions verifier. This is called through the
     * process of establishing a session.
     *
     * @see Router
     */
    abstract class PermissionsVerifier extends Ice.Object {
      /**
       * Check whether a user has permission to access the router.
       *
       * @param userId The user id for which to check permission.
       *
       * @param password The user's password.
       *
       * @param reason The reason why access was denied.
       *
       * @return True if access is granted, or false otherwise.
       *
       * @throws PermissionDeniedException Raised if the user access is
       * denied. This can be raised in place of returning false with a
       * reason set in the reason out parameter.
       */
      abstract checkPermissions(
        userId: string,
        password: string,
        current: Ice.Current
      ): Ice.OperationResult<[boolean, string]>;
    }

    /**
     * The Glacier2 permissions verifier. This is called through the
     * process of establishing a session.
     *
     * @see Router
     */
    class PermissionsVerifierPrx extends Ice.ObjectPrx {
      /**
       * Check whether a user has permission to access the router.
       *
       * @param userId The user id for which to check permission.
       *
       * @param password The user's password.
       *
       * @param reason The reason why access was denied.
       *
       * @return True if access is granted, or false otherwise.
       *
       * @throws PermissionDeniedException Raised if the user access is
       * denied. This can be raised in place of returning false with a
       * reason set in the reason out parameter.
       */
      checkPermissions(
        userId: string,
        password: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<[boolean, string]>;
    }

    /**
     * The SSL Glacier2 permissions verifier. This is called through the
     * process of establishing a session.
     *
     * @see Router
     */
    abstract class SSLPermissionsVerifier extends Ice.Object {
      /**
       * Check whether a user has permission to access the router.
       *
       * @param info The SSL information.
       *
       * @param reason The reason why access was denied.
       *
       * @return True if access is granted, or false otherwise.
       *
       * @throws PermissionDeniedException Raised if the user access is
       * denied. This can be raised in place of returning false with a
       * reason set in the reason out parameter.
       *
       * @see SSLInfo
       */
      abstract authorize(
        info: SSLInfo,
        current: Ice.Current
      ): Ice.OperationResult<[boolean, string]>;
    }

    /**
     * The SSL Glacier2 permissions verifier. This is called through the
     * process of establishing a session.
     *
     * @see Router
     */
    class SSLPermissionsVerifierPrx extends Ice.ObjectPrx {
      /**
       * Check whether a user has permission to access the router.
       *
       * @param info The SSL information.
       *
       * @param reason The reason why access was denied.
       *
       * @return True if access is granted, or false otherwise.
       *
       * @throws PermissionDeniedException Raised if the user access is
       * denied. This can be raised in place of returning false with a
       * reason set in the reason out parameter.
       *
       * @see SSLInfo
       */
      authorize(
        info: SSLInfo,
        ctx?: Ice.Context
      ): Ice.AsyncResult<[boolean, string]>;
    }
  }
}
export { Glacier2 } from \\"./Glacier2.ns\\";
"
`;

exports[`generate typings built-in slices 3`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Glacier2.ns\\" {
  namespace Glacier2 {  }
}
export { Glacier2 } from \\"./Glacier2.ns\\";
"
`;

exports[`generate typings built-in slices 4`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Router\\";
import { Glacier2 } from \\"../Glacier2/Session\\";
import \\"../Glacier2/PermissionsVerifier\\";

declare module \\"./Glacier2.ns\\" {
  /**
   * Glacier2 is a firewall solution for Ice. Glacier2 authenticates
   * and filters client requests and allows callbacks to the client in a
   * secure fashion. In combination with IceSSL, Glacier2 provides a
   * security solution that is both non-intrusive and easy to configure.
   */
  namespace Glacier2 {
    /**
     * This exception is raised if a client tries to destroy a session
     * with a router, but no session exists for the client.
     *
     * @see Router#destroySession
     */
    class SessionNotExistException extends Ice.UserException {}

    /**
     * The Glacier2 specialization of the <tt>Ice::Router</tt> interface.
     */
    abstract class Router extends Ice.Object implements Ice.Router {
      /**
       * Get the router's client proxy, i.e., the proxy to use for
       * forwarding requests from the client to the router.
       *
       * If a null proxy is returned, the client will forward requests
       * to the router's endpoints.
       *
       * @param hasRoutingTable Indicates whether or not the router supports a routing
       * table. If it is supported, the Ice runtime will call addProxies to populate the
       * routing table. This out parameter is only supported starting with Ice 3.7.
       * The Ice runtime assumes the router has a routing table if the optional is not
       * set.
       *
       * @return The router's client proxy.
       */
      abstract getClientProxy(
        current: Ice.Current
      ): Ice.OperationResult<[Ice.ObjectPrx | null, boolean | undefined]>;

      /**
       * Get the router's server proxy, i.e., the proxy to use for
       * forwarding requests from the server to the router.
       *
       * @return The router's server proxy.
       */
      abstract getServerProxy(
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Add new proxy information to the router's routing table.
       *
       * @param proxies The proxies to add.
       *
       * @return Proxies discarded by the router.
       */
      abstract addProxies(
        proxies: Ice.ObjectProxySeq,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectProxySeq>;

      /**
       * This category must be used in the identities of all of the client's
       * callback objects. This is necessary in order for the router to
       * forward callback requests to the intended client. If the Glacier2
       * server endpoints are not set, the returned category is an empty
       * string.
       *
       * @return The category.
       */
      abstract getCategoryForClient(
        current: Ice.Current
      ): Ice.OperationResult<string>;

      /**
       * Create a per-client session with the router. If a
       * {@link SessionManager} has been installed, a proxy to a {@link Session}
       * object is returned to the client. Otherwise, null is returned
       * and only an internal session (i.e., not visible to the client)
       * is created.
       *
       * If a session proxy is returned, it must be configured to route
       * through the router that created it. This will happen automatically
       * if the router is configured as the client's default router at the
       * time the session proxy is created in the client process, otherwise
       * the client must configure the session proxy explicitly.
       *
       * @see Session
       * @see SessionManager
       * @see PermissionsVerifier
       *
       * @return A proxy for the newly created session, or null if no
       * {@link SessionManager} has been installed.
       *
       * @param userId The user id for which to check the password.
       *
       * @param password The password for the given user id.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      abstract createSession(
        userId: string,
        password: string,
        current: Ice.Current
      ): Ice.OperationResult<SessionPrx | null>;

      /**
       * Create a per-client session with the router. The user is
       * authenticated through the SSL certificates that have been
       * associated with the connection. If a {@link SessionManager} has been
       * installed, a proxy to a {@link Session} object is returned to the
       * client. Otherwise, null is returned and only an internal
       * session (i.e., not visible to the client) is created.
       *
       * If a session proxy is returned, it must be configured to route
       * through the router that created it. This will happen automatically
       * if the router is configured as the client's default router at the
       * time the session proxy is created in the client process, otherwise
       * the client must configure the session proxy explicitly.
       *
       * @see Session
       * @see SessionManager
       * @see PermissionsVerifier
       *
       * @return A proxy for the newly created session, or null if no
       * {@link SessionManager} has been installed.
       *
       * @throws PermissionDeniedException Raised if the user cannot be
       * authenticated or if the user is not allowed access.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      abstract createSessionFromSecureConnection(
        current: Ice.Current
      ): Ice.OperationResult<SessionPrx | null>;

      /**
       * Keep the calling client's session with this router alive.
       *
       * @throws SessionNotExistException Raised if no session exists
       * for the calling client.
       */
      abstract refreshSession(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Destroy the calling client's session with this router.
       *
       * @throws SessionNotExistException Raised if no session exists
       * for the calling client.
       */
      abstract destroySession(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Get the value of the session timeout. Sessions are destroyed
       * if they see no activity for this period of time.
       *
       * @return The timeout (in seconds).
       */
      abstract getSessionTimeout(
        current: Ice.Current
      ): Ice.OperationResult<Ice.Long>;

      /**
       * Get the value of the ACM timeout. Clients supporting connection
       * heartbeats can enable them instead of explicitly sending keep
       * alives requests.
       *
       * NOTE: This method is only available since Ice 3.6.
       *
       * @return The timeout (in seconds).
       */
      abstract getACMTimeout(current: Ice.Current): Ice.OperationResult<number>;
    }

    /**
     * The Glacier2 specialization of the <tt>Ice::Router</tt> interface.
     */
    class RouterPrx extends Ice.ObjectPrx implements Ice.RouterPrx {
      /**
       * Get the router's client proxy, i.e., the proxy to use for
       * forwarding requests from the client to the router.
       *
       * If a null proxy is returned, the client will forward requests
       * to the router's endpoints.
       *
       * @param hasRoutingTable Indicates whether or not the router supports a routing
       * table. If it is supported, the Ice runtime will call addProxies to populate the
       * routing table. This out parameter is only supported starting with Ice 3.7.
       * The Ice runtime assumes the router has a routing table if the optional is not
       * set.
       *
       * @return The router's client proxy.
       */
      getClientProxy(
        ctx?: Ice.Context
      ): Ice.AsyncResult<[Ice.ObjectPrx | null, boolean | undefined]>;

      /**
       * Get the router's server proxy, i.e., the proxy to use for
       * forwarding requests from the server to the router.
       *
       * @return The router's server proxy.
       */
      getServerProxy(ctx?: Ice.Context): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Add new proxy information to the router's routing table.
       *
       * @param proxies The proxies to add.
       *
       * @return Proxies discarded by the router.
       */
      addProxies(
        proxies: Ice.ObjectProxySeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectProxySeq>;

      /**
       * This category must be used in the identities of all of the client's
       * callback objects. This is necessary in order for the router to
       * forward callback requests to the intended client. If the Glacier2
       * server endpoints are not set, the returned category is an empty
       * string.
       *
       * @return The category.
       */
      getCategoryForClient(ctx?: Ice.Context): Ice.AsyncResult<string>;

      /**
       * Create a per-client session with the router. If a
       * {@link SessionManager} has been installed, a proxy to a {@link Session}
       * object is returned to the client. Otherwise, null is returned
       * and only an internal session (i.e., not visible to the client)
       * is created.
       *
       * If a session proxy is returned, it must be configured to route
       * through the router that created it. This will happen automatically
       * if the router is configured as the client's default router at the
       * time the session proxy is created in the client process, otherwise
       * the client must configure the session proxy explicitly.
       *
       * @see Session
       * @see SessionManager
       * @see PermissionsVerifier
       *
       * @return A proxy for the newly created session, or null if no
       * {@link SessionManager} has been installed.
       *
       * @param userId The user id for which to check the password.
       *
       * @param password The password for the given user id.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      createSession(
        userId: string,
        password: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<SessionPrx | null>;

      /**
       * Create a per-client session with the router. The user is
       * authenticated through the SSL certificates that have been
       * associated with the connection. If a {@link SessionManager} has been
       * installed, a proxy to a {@link Session} object is returned to the
       * client. Otherwise, null is returned and only an internal
       * session (i.e., not visible to the client) is created.
       *
       * If a session proxy is returned, it must be configured to route
       * through the router that created it. This will happen automatically
       * if the router is configured as the client's default router at the
       * time the session proxy is created in the client process, otherwise
       * the client must configure the session proxy explicitly.
       *
       * @see Session
       * @see SessionManager
       * @see PermissionsVerifier
       *
       * @return A proxy for the newly created session, or null if no
       * {@link SessionManager} has been installed.
       *
       * @throws PermissionDeniedException Raised if the user cannot be
       * authenticated or if the user is not allowed access.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      createSessionFromSecureConnection(
        ctx?: Ice.Context
      ): Ice.AsyncResult<SessionPrx | null>;

      /**
       * Keep the calling client's session with this router alive.
       *
       * @throws SessionNotExistException Raised if no session exists
       * for the calling client.
       */
      refreshSession(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Destroy the calling client's session with this router.
       *
       * @throws SessionNotExistException Raised if no session exists
       * for the calling client.
       */
      destroySession(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Get the value of the session timeout. Sessions are destroyed
       * if they see no activity for this period of time.
       *
       * @return The timeout (in seconds).
       */
      getSessionTimeout(ctx?: Ice.Context): Ice.AsyncResult<Ice.Long>;

      /**
       * Get the value of the ACM timeout. Clients supporting connection
       * heartbeats can enable them instead of explicitly sending keep
       * alives requests.
       *
       * NOTE: This method is only available since Ice 3.6.
       *
       * @return The timeout (in seconds).
       */
      getACMTimeout(ctx?: Ice.Context): Ice.AsyncResult<number>;
    }
  }
}
export { Glacier2 } from \\"./Glacier2.ns\\";
"
`;

exports[`generate typings built-in slices 5`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Glacier2.ns\\" {
  namespace Glacier2 {  }
}
export { Glacier2 } from \\"./Glacier2.ns\\";
"
`;

exports[`generate typings built-in slices 6`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";
import \\"../Ice/Identity\\";
import { Glacier2 } from \\"../Glacier2/SSLInfo\\";

declare module \\"./Glacier2.ns\\" {
  namespace Glacier2 {
    /**
     * This exception is raised if an attempt to create a new session failed.
     */
    class CannotCreateSessionException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason why session creation has failed.
       */
      reason: string;
    }

    /**
     * A client-visible session object, which is tied to the lifecycle of a {@link Router}.
     *
     * @see Router
     * @see SessionManager
     */
    abstract class Session extends Ice.Object {
      /**
       * Destroy the session. This is called automatically when the router is destroyed.
       */
      abstract destroy(current: Ice.Current): Ice.OperationResult<void>;
    }

    /**
     * A client-visible session object, which is tied to the lifecycle of a {@link Router}.
     *
     * @see Router
     * @see SessionManager
     */
    class SessionPrx extends Ice.ObjectPrx {
      /**
       * Destroy the session. This is called automatically when the router is destroyed.
       */
      destroy(ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * An object for managing the set of identity constraints for specific
     * parts of object identity on a
     * {@link Session}.
     *
     * @see Session
     * @see SessionControl
     */
    abstract class StringSet extends Ice.Object {
      /**
       * Add a sequence of strings to this set of constraints. Order is
       * not preserved and duplicates are implicitly removed.
       *
       * @param additions The sequence of strings to be added.
       */
      abstract add(
        additions: Ice.StringSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Remove a sequence of strings from this set of constraints. No
       * errors are returned if an entry is not found.
       *
       * @param deletions The sequence of strings to be removed.
       */
      abstract remove(
        deletions: Ice.StringSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Returns a sequence of strings describing the constraints in this
       * set.
       *
       * @return The sequence of strings for this set.
       */
      abstract get(current: Ice.Current): Ice.OperationResult<Ice.StringSeq>;
    }

    /**
     * An object for managing the set of identity constraints for specific
     * parts of object identity on a
     * {@link Session}.
     *
     * @see Session
     * @see SessionControl
     */
    class StringSetPrx extends Ice.ObjectPrx {
      /**
       * Add a sequence of strings to this set of constraints. Order is
       * not preserved and duplicates are implicitly removed.
       *
       * @param additions The sequence of strings to be added.
       */
      add(additions: Ice.StringSeq, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Remove a sequence of strings from this set of constraints. No
       * errors are returned if an entry is not found.
       *
       * @param deletions The sequence of strings to be removed.
       */
      remove(
        deletions: Ice.StringSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Returns a sequence of strings describing the constraints in this
       * set.
       *
       * @return The sequence of strings for this set.
       */
      get(ctx?: Ice.Context): Ice.AsyncResult<Ice.StringSeq>;
    }

    /**
     * An object for managing the set of object identity constraints on a
     * {@link Session}.
     *
     * @see Session
     * @see SessionControl
     */
    abstract class IdentitySet extends Ice.Object {
      /**
       * Add a sequence of Ice identities to this set of constraints. Order is
       * not preserved and duplicates are implicitly removed.
       *
       * @param additions The sequence of Ice identities to be added.
       */
      abstract add(
        additions: Ice.IdentitySeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Remove a sequence of identities from this set of constraints. No
       * errors are returned if an entry is not found.
       *
       * @param deletions The sequence of Ice identities to be removed.
       */
      abstract remove(
        deletions: Ice.IdentitySeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Returns a sequence of identities describing the constraints in this
       * set.
       *
       * @return The sequence of Ice identities for this set.
       */
      abstract get(current: Ice.Current): Ice.OperationResult<Ice.IdentitySeq>;
    }

    /**
     * An object for managing the set of object identity constraints on a
     * {@link Session}.
     *
     * @see Session
     * @see SessionControl
     */
    class IdentitySetPrx extends Ice.ObjectPrx {
      /**
       * Add a sequence of Ice identities to this set of constraints. Order is
       * not preserved and duplicates are implicitly removed.
       *
       * @param additions The sequence of Ice identities to be added.
       */
      add(additions: Ice.IdentitySeq, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Remove a sequence of identities from this set of constraints. No
       * errors are returned if an entry is not found.
       *
       * @param deletions The sequence of Ice identities to be removed.
       */
      remove(
        deletions: Ice.IdentitySeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Returns a sequence of identities describing the constraints in this
       * set.
       *
       * @return The sequence of Ice identities for this set.
       */
      get(ctx?: Ice.Context): Ice.AsyncResult<Ice.IdentitySeq>;
    }

    /**
     * An administrative session control object, which is tied to the
     * lifecycle of a {@link Session}.
     *
     * @see Session
     */
    abstract class SessionControl extends Ice.Object {
      /**
       * Access the object that manages the allowable categories
       * for object identities for this session.
       *
       * @return A StringSet object.
       */
      abstract categories(
        current: Ice.Current
      ): Ice.OperationResult<StringSetPrx | null>;

      /**
       * Access the object that manages the allowable adapter identities
       * for objects for this session.
       *
       * @return A StringSet object.
       */
      abstract adapterIds(
        current: Ice.Current
      ): Ice.OperationResult<StringSetPrx | null>;

      /**
       * Access the object that manages the allowable object identities
       * for this session.
       *
       * @return An IdentitySet object.
       */
      abstract identities(
        current: Ice.Current
      ): Ice.OperationResult<IdentitySetPrx | null>;

      /**
       * Get the session timeout.
       *
       * @return The timeout.
       */
      abstract getSessionTimeout(
        current: Ice.Current
      ): Ice.OperationResult<number>;

      /**
       * Destroy the associated session.
       */
      abstract destroy(current: Ice.Current): Ice.OperationResult<void>;
    }

    /**
     * An administrative session control object, which is tied to the
     * lifecycle of a {@link Session}.
     *
     * @see Session
     */
    class SessionControlPrx extends Ice.ObjectPrx {
      /**
       * Access the object that manages the allowable categories
       * for object identities for this session.
       *
       * @return A StringSet object.
       */
      categories(ctx?: Ice.Context): Ice.AsyncResult<StringSetPrx | null>;

      /**
       * Access the object that manages the allowable adapter identities
       * for objects for this session.
       *
       * @return A StringSet object.
       */
      adapterIds(ctx?: Ice.Context): Ice.AsyncResult<StringSetPrx | null>;

      /**
       * Access the object that manages the allowable object identities
       * for this session.
       *
       * @return An IdentitySet object.
       */
      identities(ctx?: Ice.Context): Ice.AsyncResult<IdentitySetPrx | null>;

      /**
       * Get the session timeout.
       *
       * @return The timeout.
       */
      getSessionTimeout(ctx?: Ice.Context): Ice.AsyncResult<number>;

      /**
       * Destroy the associated session.
       */
      destroy(ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * The session manager for username/password authenticated users that
     * is responsible for managing {@link Session} objects. New session objects
     * are created by the {@link Router} object calling on an application-provided
     * session manager. If no session manager is provided by the application,
     * no client-visible sessions are passed to the client.
     *
     * @see Router
     * @see Session
     */
    abstract class SessionManager extends Ice.Object {
      /**
       * Create a new session.
       *
       * @param userId The user id for the session.
       *
       * @param control A proxy to the session control object.
       *
       * @return A proxy to the newly created session.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      abstract create(
        userId: string,
        control: SessionControlPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<SessionPrx | null>;
    }

    /**
     * The session manager for username/password authenticated users that
     * is responsible for managing {@link Session} objects. New session objects
     * are created by the {@link Router} object calling on an application-provided
     * session manager. If no session manager is provided by the application,
     * no client-visible sessions are passed to the client.
     *
     * @see Router
     * @see Session
     */
    class SessionManagerPrx extends Ice.ObjectPrx {
      /**
       * Create a new session.
       *
       * @param userId The user id for the session.
       *
       * @param control A proxy to the session control object.
       *
       * @return A proxy to the newly created session.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      create(
        userId: string,
        control: SessionControlPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<SessionPrx | null>;
    }

    /**
     * The session manager for SSL authenticated users that is
     * responsible for managing {@link Session} objects. New session objects are
     * created by the {@link Router} object calling on an application-provided
     * session manager. If no session manager is provided by the
     * application, no client-visible sessions are passed to the client.
     *
     * @see Router
     * @see Session
     */
    abstract class SSLSessionManager extends Ice.Object {
      /**
       * Create a new session.
       *
       * @param info The SSL info.
       *
       * @param control A proxy to the session control object.
       *
       * @return A proxy to the newly created session.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      abstract create(
        info: SSLInfo,
        control: SessionControlPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<SessionPrx | null>;
    }

    /**
     * The session manager for SSL authenticated users that is
     * responsible for managing {@link Session} objects. New session objects are
     * created by the {@link Router} object calling on an application-provided
     * session manager. If no session manager is provided by the
     * application, no client-visible sessions are passed to the client.
     *
     * @see Router
     * @see Session
     */
    class SSLSessionManagerPrx extends Ice.ObjectPrx {
      /**
       * Create a new session.
       *
       * @param info The SSL info.
       *
       * @param control A proxy to the session control object.
       *
       * @return A proxy to the newly created session.
       *
       * @throws CannotCreateSessionException Raised if the session
       * cannot be created.
       */
      create(
        info: SSLInfo,
        control: SessionControlPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<SessionPrx | null>;
    }
  }
}
export { Glacier2 } from \\"./Glacier2.ns\\";
"
`;

exports[`generate typings built-in slices 7`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./Glacier2.ns\\" {
  namespace Glacier2 {
    class SSLInfo implements Ice.Struct {
      constructor(
        remoteHost?: string,
        remotePort?: number,
        localHost?: string,
        localPort?: number,
        cipher?: string,
        certs?: Ice.StringSeq
      );

      remoteHost: string;
      remotePort: number;
      localHost: string;
      localPort: number;
      cipher: string;
      certs: Ice.StringSeq;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }
  }
}
export { Glacier2 } from \\"./Glacier2.ns\\";
"
`;

exports[`generate typings built-in slices 8`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    type BoolSeq = Array<boolean>;
    type ByteSeq = Uint8Array;
    type ShortSeq = Array<number>;
    type IntSeq = Array<number>;
    type LongSeq = Array<Ice.Long>;
    type FloatSeq = Array<number>;
    type DoubleSeq = Array<number>;
    type StringSeq = Array<string>;
    type ObjectSeq = Array<Ice.Object | null>;
    type ObjectProxySeq = Array<Ice.ObjectPrx | null>;
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 9`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/LoggerF\\";
import \\"../Ice/InstrumentationF\\";
import \\"../Ice/ObjectAdapterF\\";
import \\"../Ice/ObjectFactory\\";
import \\"../Ice/ValueFactory\\";
import \\"../Ice/Router\\";
import \\"../Ice/Locator\\";
import \\"../Ice/PluginF\\";
import \\"../Ice/ImplicitContextF\\";
import \\"../Ice/Current\\";
import \\"../Ice/Properties\\";
import \\"../Ice/FacetMap\\";
import \\"../Ice/Connection\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * The central object in Ice. One or more communicators can be
     * instantiated for an Ice application. Communicator instantiation
     * is language-specific, and not specified in Slice code.
     *
     * @see Logger
     * @see ObjectAdapter
     * @see Properties
     * @see ObjectFactory
     * @see ValueFactory
     */
    interface Communicator {
      /**
       * Destroy the communicator. This operation calls {@link #shutdown}
       * implicitly.  Calling {@link #destroy} cleans up memory, and shuts down
       * this communicator's client functionality and destroys all object
       * adapters. Subsequent calls to {@link #destroy} are ignored.
       *
       * @see #shutdown
       * @see ObjectAdapter#destroy
       */
      destroy(): void;

      /**
       * <p>Shuts down this communicator's server functionality, which
       * includes the deactivation of all object adapters. (Attempts to use
       * a deactivated object adapter raise {@link ObjectAdapterDeactivatedException}.)
       * Subsequent calls to {@link #shutdown} are ignored.</p>
       *
       * <p class=\\"Note\\"> After {@link #shutdown} returns, no new requests are
       * processed. However, requests that have been started before
       * {@link #shutdown} was called might still be active. You can use
       * {@link #waitForShutdown} to wait for the completion of all
       * requests.
       *
       * @see #destroy
       * @see #waitForShutdown
       * @see ObjectAdapter#deactivate
       */
      shutdown(): void;

      /**
       * Wait until the application has called {@link #shutdown} (or {@link #destroy}).
       * On the server side, this operation blocks the calling thread
       * until all currently-executing operations have completed.
       * On the client side, the operation simply block until another
       * thread has called {@link #shutdown} or {@link #destroy}.
       *
       * <p>A typical use of this operation is to call it
       * from the main thread, which then waits until some other thread
       * calls {@link #shutdown}. After shut-down is complete, the main thread
       * returns and can do some cleanup work before it finally calls
       * {@link #destroy} to shut down the client functionality, and then
       * exits the application.
       *
       * @see #shutdown
       * @see #destroy
       * @see ObjectAdapter#waitForDeactivate
       */
      waitForShutdown(): void;

      /**
       * Check whether communicator has been shut down.
       *
       * @return True if the communicator has been shut down; false otherwise.
       *
       * @see #shutdown
       */
      isShutdown(): boolean;

      /**
       * Convert a stringified proxy into a proxy. For example,
       * <tt>MyCategory/MyObject:tcp -h some_host -p
       * 10000</tt> creates a proxy that refers to the Ice object
       * having an identity with a name \\"MyObject\\" and a category
       * \\"MyCategory\\", with the server running on host \\"some_host\\", port
       * 10000. If the stringified proxy does not parse correctly, the
       * operation throws one of {@link ProxyParseException},
       * {@link EndpointParseException}, or {@link IdentityParseException}.
       * An appendix in the Ice manual provides a detailed description
       * of the syntax supported by stringified proxies.
       *
       * @param str The stringified proxy to convert into a proxy.
       *
       * @return The proxy, or nil if <tt>str</tt> is an empty string.
       *
       * @see #proxyToString
       */
      stringToProxy(str: string): Ice.ObjectPrx | null;

      /**
       * Convert a proxy into a string.
       *
       * @param obj The proxy to convert into a stringified proxy.
       *
       * @return The stringified proxy, or an empty string if
       * <tt>obj</tt> is nil.
       *
       * @see #stringToProxy
       */
      proxyToString(obj: Ice.ObjectPrx | null): string;

      /**
       * Convert a set of proxy properties into a proxy. The \\"base\\"
       * name supplied in the <tt>property</tt> argument refers to a
       * property containing a stringified proxy, such as
       * <tt>MyProxy=id:tcp -h localhost -p 10000</tt>. Additional
       * properties configure local settings for the proxy, such as
       * <tt>MyProxy.PreferSecure=1</tt>. The \\"Properties\\"
       * appendix in the Ice manual describes each of the supported
       * proxy properties.
       *
       * @param property The base property name.
       *
       * @return The proxy.
       */
      propertyToProxy(property: string): Ice.ObjectPrx | null;

      /**
       * Convert a proxy to a set of proxy properties.
       *
       * @param proxy The proxy.
       *
       * @param property The base property name.
       *
       * @return The property set.
       */
      proxyToProperty(
        proxy: Ice.ObjectPrx | null,
        property: string
      ): PropertyDict;

      /**
       * Convert a string into an identity. If the string does not parse
       * correctly, the operation throws {@link IdentityParseException}.
       *
       * @param str The string to convert into an identity.
       *
       * @return The identity.
       *
       * @see #identityToString
       */
      stringToIdentity(str: string): Identity;

      /**
       * Convert an identity into a string.
       *
       * @param ident The identity to convert into a string.
       *
       * @return The \\"stringified\\" identity.
       *
       * @see #stringToIdentity
       */
      identityToString(ident: Identity): string;

      /**
       * <p>Create a new object adapter. The endpoints for the object
       * adapter are taken from the property <tt><em>name</em>.Endpoints</tt>.</p>
       *
       * <p>It is legal to create an object adapter with the empty string as
       * its name. Such an object adapter is accessible via bidirectional
       * connections or by collocated invocations that originate from the
       * same communicator as is used by the adapter.</p>
       *
       * <p>Attempts to create a named object adapter for which no configuration
       * can be found raise {@link InitializationException}.
       *
       * @param name The object adapter name.
       *
       * @return The new object adapter.
       *
       * @see #createObjectAdapterWithEndpoints
       * @see ObjectAdapter
       * @see Properties
       */
      createObjectAdapter(name: string): ObjectAdapter;

      /**
       * <p>Create a new object adapter with endpoints. This operation sets
       * the property <tt><em>name</em>.Endpoints</tt>,
       * and then calls {@link #createObjectAdapter}. It is provided as a
       * convenience function.</p>
       *
       * <p>Calling this operation with an empty name will result in a
       * UUID being generated for the name.
       *
       * @param name The object adapter name.
       *
       * @param endpoints The endpoints for the object adapter.
       *
       * @return The new object adapter.
       *
       * @see #createObjectAdapter
       * @see ObjectAdapter
       * @see Properties
       */
      createObjectAdapterWithEndpoints(
        name: string,
        endpoints: string
      ): ObjectAdapter;

      /**
       * <p>Create a new object adapter with a router. This operation
       * creates a routed object adapter.</p>
       *
       * <p>Calling this operation with an empty name will result in a
       * UUID being generated for the name.
       *
       * @param name The object adapter name.
       *
       * @param rtr The router.
       *
       * @return The new object adapter.
       *
       * @see #createObjectAdapter
       * @see ObjectAdapter
       * @see Properties
       */
      createObjectAdapterWithRouter(
        name: string,
        rtr: RouterPrx | null
      ): ObjectAdapter;

      /**
       * <p>Add an object factory to this communicator. Installing a
       * factory with an id for which a factory is already registered
       * throws {@link AlreadyRegisteredException}.</p>
       *
       * <p>When unmarshaling an Ice object, the Ice run time reads the
       * most-derived type id off the wire and attempts to create an
       * instance of the type using a factory. If no instance is created,
       * either because no factory was found, or because all factories
       * returned nil, the behavior of the Ice run time depends on the
       * format with which the object was marshaled:</p>
       *
       * <p>If the object uses the \\"sliced\\" format, Ice ascends the class
       * hierarchy until it finds a type that is recognized by a factory,
       * or it reaches the least-derived type. If no factory is found that
       * can create an instance, the run time throws
       * {@link NoValueFactoryException}.</p>
       *
       * <p>If the object uses the \\"compact\\" format, Ice immediately raises
       * {@link NoValueFactoryException}.</p>
       *
       * <p>The following order is used to locate a factory for a type:</p>
       *
       * <ol>
       *
       * <li>The Ice run-time looks for a factory registered
       * specifically for the type.</li>
       *
       * <li>If no instance has been created, the Ice run-time looks
       * for the default factory, which is registered with an empty type id.
       * </li>
       *
       * <li>If no instance has been created by any of the preceding
       * steps, the Ice run-time looks for a factory that may have been
       * statically generated by the language mapping for non-abstract classes.
       * </li>
       *
       * </ol>
       *
       * @param factory The factory to add.
       *
       * @param id The type id for which the factory can create instances, or
       * an empty string for the default factory.
       *
       * @see #findObjectFactory
       * @see ObjectFactory
       * @see ValueFactoryManager#add
       */
      addObjectFactory(factory: ObjectFactory, id: string): void;

      /**
       * Find an object factory registered with this communicator.
       *
       * @param id The type id for which the factory can create instances,
       * or an empty string for the default factory.
       *
       * @return The object factory, or null if no object factory was
       * found for the given id.
       *
       * @see #addObjectFactory
       * @see ObjectFactory
       * @see ValueFactoryManager#find
       */
      findObjectFactory(id: string): ObjectFactory;

      /**
       * Get the implicit context associated with this communicator.
       *
       * @return The implicit context associated with this communicator;
       * returns null when the property Ice.ImplicitContext is not set
       * or is set to None.
       */
      getImplicitContext(): ImplicitContext;

      /**
       * Get the properties for this communicator.
       *
       * @return This communicator's properties.
       *
       * @see Properties
       */
      getProperties(): Properties;

      /**
       * Get the logger for this communicator.
       *
       * @return This communicator's logger.
       *
       * @see Logger
       */
      getLogger(): Logger;

      /**
       * Get the observer resolver object for this communicator.
       *
       * @return This communicator's observer resolver object.
       */
      getObserver(): Ice.Instrumentation.CommunicatorObserver;

      /**
       * Get the default router this communicator.
       *
       * @return The default router for this communicator.
       *
       * @see #setDefaultRouter
       * @see Router
       */
      getDefaultRouter(): RouterPrx | null;

      /**
       * <p>Set a default router for this communicator. All newly
       * created proxies will use this default router. To disable the
       * default router, null can be used. Note that this
       * operation has no effect on existing proxies.</p>
       *
       * <p class=\\"Note\\">You can also set a router for an individual proxy
       * by calling the operation <tt>ice_router</tt> on the proxy.
       *
       * @param rtr The default router to use for this communicator.
       *
       * @see #getDefaultRouter
       * @see #createObjectAdapterWithRouter
       * @see Router
       */
      setDefaultRouter(rtr: RouterPrx | null): void;

      /**
       * Get the default locator this communicator.
       *
       * @return The default locator for this communicator.
       *
       * @see #setDefaultLocator
       * @see Locator
       */
      getDefaultLocator(): LocatorPrx | null;

      /**
       * <p>Set a default Ice locator for this communicator. All newly
       * created proxy and object adapters will use this default
       * locator. To disable the default locator, null can be used.
       * Note that this operation has no effect on existing proxies or
       * object adapters.</p>
       *
       * <p class=\\"Note\\"> You can also set a locator for an individual proxy
       * by calling the operation <tt>ice_locator</tt> on the proxy, or for an
       * object adapter by calling the operation {@link ObjectAdapter#setLocator}
       * on the object adapter.
       *
       * @param loc The default locator to use for this communicator.
       *
       * @see #getDefaultLocator
       * @see Locator
       * @see ObjectAdapter#setLocator
       */
      setDefaultLocator(loc: LocatorPrx | null): void;

      /**
       * Get the plug-in manager for this communicator.
       *
       * @return This communicator's plug-in manager.
       *
       * @see PluginManager
       */
      getPluginManager(): PluginManager;

      /**
       * Get the value factory manager for this communicator.
       *
       * @return This communicator's value factory manager.
       *
       * @see ValueFactoryManager
       */
      getValueFactoryManager(): ValueFactoryManager;

      /**
       * Flush any pending batch requests for this communicator.
       * This means all batch requests invoked on fixed proxies
       * for all connections associated with the communicator.
       * Any errors that occur while flushing a connection are ignored.
       *
       * @param compress Specifies whether or not the queued batch requests
       * should be compressed before being sent over the wire.
       */
      flushBatchRequests(compress: CompressBatch): void;

      /**
       * Add the Admin object with all its facets to the provided object adapter.
       * If Ice.Admin.ServerId is set and the provided object adapter has a {@link Locator},
       * createAdmin registers the Admin's Process facet with the {@link Locator}'s {@link LocatorRegistry}.
       *
       * <p>createAdmin call only be called once; subsequent calls raise {@link InitializationException}.</p>
       *
       * @param adminAdapter The object adapter used to host the Admin object; if null and
       * Ice.Admin.Endpoints is set, create, activate and use the Ice.Admin object adapter.
       *
       * @param adminId The identity of the Admin object.
       *
       * @return A proxy to the main (\\"\\") facet of the Admin object. Never returns a null proxy.
       *
       * @see #getAdmin
       */
      createAdmin(
        adminAdapter: ObjectAdapter,
        adminId: Identity
      ): Ice.ObjectPrx | null;

      /**
       * *
       * * Get a proxy to the main facet of the Admin object.
       * *
       * * getAdmin also creates the Admin object and creates and activates the Ice.Admin object
       * * adapter to host this Admin object if Ice.Admin.Enpoints is set. The identity of the Admin
       * * object created by getAdmin is {value of Ice.Admin.InstanceName}/admin, or {UUID}/admin
       * * when Ice.Admin.InstanceName is not set.
       * *
       * * <p>If Ice.Admin.DelayCreation is 0 or not set, getAdmin is called by the communicator
       * * initialization, after initialization of all plugins.</p>
       *
       * * @return A proxy to the main (\\"\\") facet of the Admin object, or a null proxy if no
       * * Admin object is configured.
       * *
       * * @see #createAdmin
       */
      getAdmin(): Ice.ObjectPrx | null;

      /**
       * Add a new facet to the Admin object.
       * Adding a servant with a facet that is already registered
       * throws {@link AlreadyRegisteredException}.
       *
       * @param servant The servant that implements the new Admin facet.
       * @param facet The name of the new Admin facet.
       */
      addAdminFacet(servant: Ice.Object | null, facet: string): void;

      /**
       * Remove the following facet to the Admin object.
       * Removing a facet that was not previously registered throws
       * {@link NotRegisteredException}.
       *
       * @param facet The name of the Admin facet.
       * @return The servant associated with this Admin facet.
       */
      removeAdminFacet(facet: string): Ice.Object | null;

      /**
       * Returns a facet of the Admin object.
       *
       * @param facet The name of the Admin facet.
       * @return The servant associated with this Admin facet, or
       * null if no facet is registered with the given name.
       */
      findAdminFacet(facet: string): Ice.Object | null;

      /**
       * Returns a map of all facets of the Admin object.
       *
       * @return A collection containing all the facet names and
       * servants of the Admin object.
       *
       * @see #findAdminFacet
       */
      findAllAdminFacets(): FacetMap;
    }

    type ToStringModeName = \\"Unicode\\" | \\"ASCII\\" | \\"Compat\\";

    /**
     * The output mode for xxxToString method such as identityToString and proxyToString.
     * The actual encoding format for the string is the same for all modes: you
     * don't need to specify an encoding format or mode when reading such a string.
     */
    class ToStringMode<
      Name extends ToStringModeName = ToStringModeName
    > extends Ice.EnumBase<Name> {
      /**
       * Characters with ordinal values greater than 127 are kept as-is in the resulting string.
       * Non-printable ASCII characters with ordinal values 127 and below are encoded as \\\\\\\\t, \\\\\\\\n (etc.)
       * or \\\\\\\\unnnn.
       */
      static Unicode: ToStringMode<\\"Unicode\\">;

      /**
       * Characters with ordinal values greater than 127 are encoded as universal character names in
       * the resulting string: \\\\\\\\unnnn for BMP characters and \\\\\\\\Unnnnnnnn for non-BMP characters.
       * Non-printable ASCII characters with ordinal values 127 and below are encoded as \\\\\\\\t, \\\\\\\\n (etc.)
       * or \\\\\\\\unnnn.
       */
      static ASCII: ToStringMode<\\"ASCII\\">;

      /**
       * Characters with ordinal values greater than 127 are encoded as a sequence of UTF-8 bytes using
       * octal escapes. Characters with ordinal values 127 and below are encoded as \\\\\\\\t, \\\\\\\\n (etc.) or
       * an octal escape. Use this mode to generate strings compatible with Ice 3.6 and earlier.
       */
      static Compat: ToStringMode<\\"Compat\\">;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 10`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 11`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/ObjectAdapterF\\";
import \\"../Ice/Identity\\";
import \\"../Ice/Endpoint\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    type CompressBatchName = \\"Yes\\" | \\"No\\" | \\"BasedOnProxy\\";

    /**
     * The batch compression option when flushing queued batch requests.
     */
    class CompressBatch<
      Name extends CompressBatchName = CompressBatchName
    > extends Ice.EnumBase<Name> {
      /**
       * Compress the batch requests.
       */
      static Yes: CompressBatch<\\"Yes\\">;

      /**
       * Don't compress the batch requests.
       */
      static No: CompressBatch<\\"No\\">;

      /**
       * Compress the batch requests if at least one request was
       * made on a compressed proxy.
       */
      static BasedOnProxy: CompressBatch<\\"BasedOnProxy\\">;
    }

    /**
     * Base class providing access to the connection details. *
     */
    class ConnectionInfo {
      constructor(
        underlying?: ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string
      );

      /**
       * The information of the underyling transport or null if there's
       * no underlying transport.
       */
      underlying: ConnectionInfo | null;

      /**
       * Whether or not the connection is an incoming or outgoing
       * connection.
       */
      incoming: boolean;

      /**
       * The name of the adapter associated with the connection.
       */
      adapterName: string;

      /**
       * The connection id.
       */
      connectionId: string;
    }

    /**
     * An application can implement this interface to receive notifications when
     * a connection closes.
     *
     * @see Connection#setCloseCallback
     */
    interface CloseCallback {
      /**
       * This method is called by the the connection when the connection
       * is closed. If the callback needs more information about the closure,
       * it can call {@link Connection#throwException}.
       *
       * @param con The connection that closed.
       */
      closed(con: Connection): void;
    }

    /**
     * An application can implement this interface to receive notifications when
     * a connection receives a heartbeat message.
     *
     * @see Connection#setHeartbeatCallback
     */
    interface HeartbeatCallback {
      /**
       * This method is called by the the connection when a heartbeat is
       * received from the peer.
       *
       * @param con The connection on which a heartbeat was received.
       */
      heartbeat(con: Connection): void;
    }

    type ACMCloseName =
      | \\"CloseOff\\"
      | \\"CloseOnIdle\\"
      | \\"CloseOnInvocation\\"
      | \\"CloseOnInvocationAndIdle\\"
      | \\"CloseOnIdleForceful\\";

    class ACMClose<
      Name extends ACMCloseName = ACMCloseName
    > extends Ice.EnumBase<Name> {
      static CloseOff: ACMClose<\\"CloseOff\\">;
      static CloseOnIdle: ACMClose<\\"CloseOnIdle\\">;
      static CloseOnInvocation: ACMClose<\\"CloseOnInvocation\\">;
      static CloseOnInvocationAndIdle: ACMClose<\\"CloseOnInvocationAndIdle\\">;
      static CloseOnIdleForceful: ACMClose<\\"CloseOnIdleForceful\\">;
    }

    type ACMHeartbeatName =
      | \\"HeartbeatOff\\"
      | \\"HeartbeatOnDispatch\\"
      | \\"HeartbeatOnIdle\\"
      | \\"HeartbeatAlways\\";

    class ACMHeartbeat<
      Name extends ACMHeartbeatName = ACMHeartbeatName
    > extends Ice.EnumBase<Name> {
      static HeartbeatOff: ACMHeartbeat<\\"HeartbeatOff\\">;
      static HeartbeatOnDispatch: ACMHeartbeat<\\"HeartbeatOnDispatch\\">;
      static HeartbeatOnIdle: ACMHeartbeat<\\"HeartbeatOnIdle\\">;
      static HeartbeatAlways: ACMHeartbeat<\\"HeartbeatAlways\\">;
    }

    class ACM implements Ice.Struct {
      constructor(timeout?: number, close?: ACMClose, heartbeat?: ACMHeartbeat);

      timeout: number;
      close: ACMClose;
      heartbeat: ACMHeartbeat;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    type ConnectionCloseName =
      | \\"Forcefully\\"
      | \\"Gracefully\\"
      | \\"GracefullyWithWait\\";

    /**
     * Determines the behavior when manually closing a connection.
     */
    class ConnectionClose<
      Name extends ConnectionCloseName = ConnectionCloseName
    > extends Ice.EnumBase<Name> {
      /**
       * Close the connection immediately without sending a close connection protocol message to the peer
       * and waiting for the peer to acknowledge it.
       */
      static Forcefully: ConnectionClose<\\"Forcefully\\">;

      /**
       * Close the connection by notifying the peer but do not wait for pending outgoing invocations to complete.
       * On the server side, the connection will not be closed until all incoming invocations have completed.
       */
      static Gracefully: ConnectionClose<\\"Gracefully\\">;

      /**
       * Wait for all pending invocations to complete before closing the connection.
       */
      static GracefullyWithWait: ConnectionClose<\\"GracefullyWithWait\\">;
    }

    /**
     * The user-level interface to a connection.
     */
    interface Connection {
      /**
       * Manually close the connection using the specified closure mode.
       *
       * @param mode Determines how the connection will be closed.
       *
       * @see ConnectionClose
       */
      close(mode: ConnectionClose): void;

      /**
       * Create a special proxy that always uses this connection. This
       * can be used for callbacks from a server to a client if the
       * server cannot directly establish a connection to the client,
       * for example because of firewalls. In this case, the server
       * would create a proxy using an already established connection
       * from the client.
       *
       * @param id The identity for which a proxy is to be created.
       *
       * @return A proxy that matches the given identity and uses this
       * connection.
       *
       * @see #setAdapter
       */
      createProxy(id: Identity): Ice.ObjectPrx | null;

      /**
       * Explicitly set an object adapter that dispatches requests that
       * are received over this connection. A client can invoke an
       * operation on a server using a proxy, and then set an object
       * adapter for the outgoing connection that is used by the proxy
       * in order to receive callbacks. This is useful if the server
       * cannot establish a connection back to the client, for example
       * because of firewalls.
       *
       * @param adapter The object adapter that should be used by this
       * connection to dispatch requests. The object adapter must be
       * activated. When the object adapter is deactivated, it is
       * automatically removed from the connection.
       *
       * @see #createProxy
       * @see #getAdapter
       */
      setAdapter(adapter: ObjectAdapter): void;

      /**
       * Get the object adapter that dispatches requests for this
       * connection.
       *
       * @return The object adapter that dispatches requests for the
       * connection, or null if no adapter is set.
       *
       * @see #setAdapter
       */
      getAdapter(): ObjectAdapter;

      /**
       * Get the endpoint from which the connection was created.
       *
       * @return The endpoint from which the connection was created.
       */
      getEndpoint(): Endpoint;

      /**
       * Flush any pending batch requests for this connection.
       * This means all batch requests invoked on fixed proxies
       * associated with the connection.
       *
       * @param compress Specifies whether or not the queued batch requests
       * should be compressed before being sent over the wire.
       */
      flushBatchRequests(compress: CompressBatch): void;

      /**
       * Set a close callback on the connection. The callback is called by the
       * connection when it's closed. The callback is called from the
       * Ice thread pool associated with the connection. If the callback needs
       * more information about the closure, it can call {@link Connection#throwException}.
       *
       * @param callback The close callback object.
       */
      setCloseCallback(callback: CloseCallback): void;

      /**
       * Set a heartbeat callback on the connection. The callback is called by the
       * connection when a heartbeat is received. The callback is called
       * from the Ice thread pool associated with the connection.
       *
       * @param callback The heartbeat callback object.
       */
      setHeartbeatCallback(callback: HeartbeatCallback): void;

      /**
       * Send a heartbeat message.
       */
      heartbeat(): void;

      /**
       * Set the active connection management parameters.
       *
       * @param timeout The timeout value in milliseconds.
       *
       * @param close The close condition
       *
       * @param heartbeat The hertbeat condition
       */
      setACM(
        timeout?: number,
        close?: ACMClose,
        heartbeat?: ACMHeartbeat
      ): void;

      /**
       * Get the ACM parameters.
       *
       * @return The ACM parameters.
       */
      getACM(): ACM;

      /**
       * Return the connection type. This corresponds to the endpoint
       * type, i.e., \\"tcp\\", \\"udp\\", etc.
       *
       * @return The type of the connection.
       */
      type(): string;

      /**
       * Get the timeout for the connection.
       *
       * @return The connection's timeout.
       */
      timeout(): number;

      /**
       * Return a description of the connection as human readable text,
       * suitable for logging or error messages.
       *
       * @return The description of the connection as human readable
       * text.
       */
      toString(): string;

      /**
       * Returns the connection information.
       *
       * @return The connection information.
       */
      getInfo(): ConnectionInfo | null;

      /**
       * Set the connection buffer receive/send size.
       *
       * @param rcvSize The connection receive buffer size.
       * @param sndSize The connection send buffer size.
       */
      setBufferSize(rcvSize: number, sndSize: number): void;

      /**
       * Throw an exception indicating the reason for connection closure. For example,
       * {@link CloseConnectionException} is raised if the connection was closed gracefully,
       * whereas {@link ConnectionManuallyClosedException} is raised if the connection was
       * manually closed by the application. This operation does nothing if the connection is
       * not yet closed.
       */
      throwException(): void;
    }

    /**
     * Provides access to the connection details of an IP connection
     */
    class IPConnectionInfo extends ConnectionInfo {
      constructor(
        underlying?: ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string,
        localAddress?: string,
        localPort?: number,
        remoteAddress?: string,
        remotePort?: number
      );

      localAddress: string;
      localPort: number;
      remoteAddress: string;
      remotePort: number;
    }

    /**
     * Provides access to the connection details of a TCP connection
     */
    class TCPConnectionInfo extends IPConnectionInfo {
      constructor(
        underlying?: ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string,
        localAddress?: string,
        localPort?: number,
        remoteAddress?: string,
        remotePort?: number,
        rcvSize?: number,
        sndSize?: number
      );

      /**
       * The connection buffer receive size.
       */
      rcvSize: number;

      /**
       * The connection buffer send size.
       */
      sndSize: number;
    }

    /**
     * Provides access to the connection details of a UDP connection
     */
    class UDPConnectionInfo extends IPConnectionInfo {
      constructor(
        underlying?: ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string,
        localAddress?: string,
        localPort?: number,
        remoteAddress?: string,
        remotePort?: number,
        mcastAddress?: string,
        mcastPort?: number,
        rcvSize?: number,
        sndSize?: number
      );

      /**
       * The multicast address.
       */
      mcastAddress: string;

      /**
       * The multicast port.
       */
      mcastPort: number;

      /**
       * The connection buffer receive size.
       */
      rcvSize: number;

      /**
       * The connection buffer send size.
       */
      sndSize: number;
    }

    type HeaderDict = Map<string, string>;

    /**
     * Provides access to the connection details of a WebSocket connection
     */
    class WSConnectionInfo extends ConnectionInfo {
      constructor(
        underlying?: ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string,
        headers?: HeaderDict
      );

      headers: HeaderDict;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 12`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 13`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/ObjectAdapterF\\";
import \\"../Ice/ConnectionF\\";
import \\"../Ice/Identity\\";
import \\"../Ice/Version\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A request context. <tt>Context</tt> is used to transmit metadata about a
     * request from the server to the client, such as Quality-of-Service
     * (QoS) parameters. Each operation on the client has a <tt>Context</tt> as
     * its implicit final parameter.
     */
    type Context = Map<string, string>;

    type OperationModeName = \\"Normal\\" | \\"Nonmutating\\" | \\"Idempotent\\";

    class OperationMode<
      Name extends OperationModeName = OperationModeName
    > extends Ice.EnumBase<Name> {
      static Normal: OperationMode<\\"Normal\\">;
      static Nonmutating: OperationMode<\\"Nonmutating\\">;
      static Idempotent: OperationMode<\\"Idempotent\\">;
    }

    /**
     * Information about the current method invocation for servers. Each
     * operation on the server has a <tt>Current</tt> as its implicit final
     * parameter. <tt>Current</tt> is mostly used for Ice services. Most
     * applications ignore this parameter.
     */
    class Current implements Ice.Struct {
      constructor(
        adapter?: ObjectAdapter,
        con?: Connection,
        id?: Identity,
        facet?: string,
        operation?: string,
        mode?: OperationMode,
        ctx?: Context,
        requestId?: number,
        encoding?: Ice.EncodingVersion
      );

      /**
       * The object adapter.
       */
      adapter: ObjectAdapter;

      /**
       * Information about the connection over which the current method
       * invocation was received. If the invocation is direct due to
       * collocation optimization, this value is set to null.
       */
      con: Connection;

      /**
       * The Ice object identity.
       */
      id: Identity;

      facet: string;

      /**
       * The operation name.
       */
      operation: string;

      /**
       * The mode of the operation.
       */
      mode: OperationMode;

      /**
       * The request context, as received from the client.
       */
      ctx: Context;

      /**
       * The request id unless oneway (0) or collocated (-1).
       */
      requestId: number;

      /**
       * The encoding version used to encode the input and output parameters.
       */
      encoding: Ice.EncodingVersion;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 14`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Version\\";
import \\"../Ice/BuiltinSequences\\";
import \\"../Ice/EndpointF\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * Uniquely identifies TCP endpoints.
     */
    const TCPEndpointType: number;

    /**
     * Uniquely identifies SSL endpoints.
     */
    const SSLEndpointType: number;

    /**
     * Uniquely identifies UDP endpoints.
     */
    const UDPEndpointType: number;

    /**
     * Uniquely identifies TCP-based WebSocket endpoints.
     */
    const WSEndpointType: number;

    /**
     * Uniquely identifies SSL-based WebSocket endpoints.
     */
    const WSSEndpointType: number;

    /**
     * Uniquely identifies Bluetooth endpoints.
     */
    const BTEndpointType: number;

    /**
     * Uniquely identifies SSL Bluetooth endpoints.
     */
    const BTSEndpointType: number;

    /**
     * Uniquely identifies iAP-based endpoints.
     */
    const iAPEndpointType: number;

    /**
     * Uniquely identifies SSL iAP-based endpoints.
     */
    const iAPSEndpointType: number;

    /**
     * Base class providing access to the endpoint details.
     */
    class EndpointInfo {
      constructor(
        underlying?: EndpointInfo | null,
        timeout?: number,
        compress?: boolean
      );

      /**
       * The information of the underyling endpoint of null if there's
       * no underlying endpoint.
       */
      underlying: EndpointInfo | null;

      /**
       * The timeout for the endpoint in milliseconds. 0 means
       * non-blocking, -1 means no timeout.
       */
      timeout: number;

      compress: boolean;

      /**
       * Returns the type of the endpoint.
       *
       * @return The endpoint type.
       */
      type(): number;

      /**
       * Returns true if this endpoint is a datagram endpoint.
       *
       * @return True for a datagram endpoint.
       */
      datagram(): boolean;

      /**
       * Returns true if this endpoint is a secure endpoint.
       *
       * @return True for a secure endpoint.
       */
      secure(): boolean;
    }

    /**
     * The user-level interface to an endpoint.
     */
    interface Endpoint {
      /**
       * Return a string representation of the endpoint.
       *
       * @return The string representation of the endpoint.
       */
      toString(): string;

      /**
       * Returns the endpoint information.
       *
       * @return The endpoint information class.
       */
      getInfo(): EndpointInfo | null;
    }

    /**
     * Provides access to the address details of a IP endpoint.
     *
     * @see Endpoint
     */
    class IPEndpointInfo extends EndpointInfo {
      constructor(
        underlying?: EndpointInfo | null,
        timeout?: number,
        compress?: boolean,
        host?: string,
        port?: number,
        sourceAddress?: string
      );

      /**
       * The host or address configured with the endpoint.
       */
      host: string;

      /**
       * The port number.
       */
      port: number;

      sourceAddress: string;
    }

    /**
     * Provides access to a TCP endpoint information.
     *
     * @see Endpoint
     */
    class TCPEndpointInfo extends IPEndpointInfo {}

    /**
     * Provides access to an UDP endpoint information.
     *
     * @see Endpoint
     */
    class UDPEndpointInfo extends IPEndpointInfo {
      constructor(
        underlying?: EndpointInfo | null,
        timeout?: number,
        compress?: boolean,
        host?: string,
        port?: number,
        sourceAddress?: string,
        mcastInterface?: string,
        mcastTtl?: number
      );

      /**
       * The multicast interface.
       */
      mcastInterface: string;

      /**
       * The multicast time-to-live (or hops).
       */
      mcastTtl: number;
    }

    /**
     * Provides access to a WebSocket endpoint information.
     */
    class WSEndpointInfo extends EndpointInfo {
      constructor(
        underlying?: EndpointInfo | null,
        timeout?: number,
        compress?: boolean,
        resource?: string
      );

      /**
       * The URI configured with the endpoint.
       */
      resource: string;
    }

    /**
     * Provides access to the details of an opaque endpoint.
     *
     * @see Endpoint
     */
    class OpaqueEndpointInfo extends EndpointInfo {
      constructor(
        underlying?: EndpointInfo | null,
        timeout?: number,
        compress?: boolean,
        rawEncoding?: Ice.EncodingVersion,
        rawBytes?: Ice.ByteSeq
      );

      /**
       * The encoding version of the opaque endpoint (to decode or
       * encode the rawBytes).
       */
      rawEncoding: Ice.EncodingVersion;

      /**
       * The raw encoding of the opaque endpoint.
       */
      rawBytes: Ice.ByteSeq;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 15`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A sequence of endpoints.
     */
    type EndpointSeq = Array<Endpoint>;
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 16`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    type EndpointSelectionTypeName = \\"Random\\" | \\"Ordered\\";

    /**
     * Determines the order in which the Ice run time uses the endpoints
     * in a proxy when establishing a connection.
     */
    class EndpointSelectionType<
      Name extends EndpointSelectionTypeName = EndpointSelectionTypeName
    > extends Ice.EnumBase<Name> {
      static Random: EndpointSelectionType<\\"Random\\">;
      static Ordered: EndpointSelectionType<\\"Ordered\\">;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 17`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A mapping from facet name to servant.
     */
    type FacetMap = Map<string, Ice.Object | null>;
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 18`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * The identity of an Ice object. In a proxy, an empty {@link Identity#name} denotes a nil
     * proxy. An identity with an empty {@link Identity#name} and a non-empty {@link Identity#category}
     * is illegal. You cannot add a servant with an empty name to the Active Servant Map.
     *
     * @see ServantLocator
     * @see ObjectAdapter#addServantLocator
     */
    class Identity implements Ice.Struct {
      constructor(name?: string, category?: string);

      /**
       * The name of the Ice object.
       */
      name: string;

      /**
       * The Ice object category.
       */
      category: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    type ObjectDict = Ice.HashMap<Identity, Ice.Object | null>;

    /**
     * A sequence of identities.
     */
    type IdentitySeq = Array<Identity>;
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 19`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/LocalException\\";
import \\"../Ice/Current\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * An interface to associate implict contexts with communicators.
     *
     * <p>When you make a remote invocation without an explicit context parameter,
     * Ice uses the per-proxy context (if any) combined with the <tt>ImplicitContext</tt>
     * associated with the communicator.</p>
     *
     * <p>Ice provides several implementations of <tt>ImplicitContext</tt>. The implementation
     * used depends on the value of the <tt>Ice.ImplicitContext</tt> property.
     * <dl>
     * <dt><tt>None</tt> (default)</dt>
     * <dd>No implicit context at all.</dd>
     * <dt><tt>PerThread</tt></dt>
     * <dd>The implementation maintains a context per thread.</dd>
     * <dt><tt>Shared</tt></dt>
     * <dd>The implementation maintains a single context shared by all threads.</dd>
     * </dl><p>
     *
     * <tt>ImplicitContext</tt> also provides a number of operations to create, update or retrieve
     * an entry in the underlying context without first retrieving a copy of the entire
     * context. These operations correspond to a subset of the <tt>java.util.Map</tt> methods,
     * with <tt>java.lang.Object</tt> replaced by <tt>string</tt> and null replaced by the empty-string.
     */
    interface ImplicitContext {
      /**
       * Get a copy of the underlying context.
       * @return A copy of the underlying context.
       */
      getContext(): Context;

      /**
       * Set the underlying context.
       *
       * @param newContext The new context.
       */
      setContext(newContext: Context): void;

      /**
       * Check if this key has an associated value in the underlying context.
       *
       * @param key The key.
       *
       * @return True if the key has an associated value, False otherwise.
       */
      containsKey(key: string): boolean;

      /**
       * Get the value associated with the given key in the underlying context.
       * Returns an empty string if no value is associated with the key.
       * {@link #containsKey} allows you to distinguish between an empty-string value and
       * no value at all.
       *
       * @param key The key.
       *
       * @return The value associated with the key.
       */
      get(key: string): string;

      /**
       * Create or update a key/value entry in the underlying context.
       *
       * @param key The key.
       *
       * @param value The value.
       *
       * @return The previous value associated with the key, if any.
       */
      put(key: string, value: string): string;

      /**
       * Remove the entry for the given key in the underlying context.
       *
       * @param key The key.
       *
       * @return The value associated with the key, if any.
       */
      remove(key: string): string;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 20`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 21`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/EndpointF\\";
import \\"../Ice/ConnectionF\\";
import \\"../Ice/Current\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * The Instrumentation local interfaces enable observing a number of
     * Ice core internal components (threads, connections, etc).
     */
    namespace Instrumentation {
      /**
       * The object observer interface used by instrumented objects to
       * notify the observer of their existence.
       */
      interface Observer {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;
      }

      type ThreadStateName =
        | \\"ThreadStateIdle\\"
        | \\"ThreadStateInUseForIO\\"
        | \\"ThreadStateInUseForUser\\"
        | \\"ThreadStateInUseForOther\\";

      /**
       * The thread state enumeration keeps track of the different possible
       * states of Ice threads.
       */
      class ThreadState<
        Name extends ThreadStateName = ThreadStateName
      > extends Ice.EnumBase<Name> {
        /**
         * The thread is idle.
         */
        static ThreadStateIdle: ThreadState<\\"ThreadStateIdle\\">;

        /**
         * The thread is in use performing reads or writes for Ice
         * connections. This state is only for threads from an Ice thread
         * pool.
         */
        static ThreadStateInUseForIO: ThreadState<\\"ThreadStateInUseForIO\\">;

        /**
         * The thread is calling user code (servant implementation, AMI
         * callbacks). This state is only for threads from an Ice thread
         * pool.
         */
        static ThreadStateInUseForUser: ThreadState<\\"ThreadStateInUseForUser\\">;

        /**
         * The thread is performing other internal activities (DNS
         * lookups, timer callbacks, etc).
         */
        static ThreadStateInUseForOther: ThreadState<
          \\"ThreadStateInUseForOther\\"
        >;
      }

      /**
       * The thread observer interface to instrument Ice threads. This can
       * be threads from the Ice thread pool or utility threads used by the
       * Ice core.
       */
      interface ThreadObserver extends Observer {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;

        /**
         * Notification of thread state change.
         *
         * @param oldState The previous thread state.
         *
         * @param newState The new thread state.
         */
        stateChanged(oldState: ThreadState, newState: ThreadState): void;
      }

      type ConnectionStateName =
        | \\"ConnectionStateValidating\\"
        | \\"ConnectionStateHolding\\"
        | \\"ConnectionStateActive\\"
        | \\"ConnectionStateClosing\\"
        | \\"ConnectionStateClosed\\";

      /**
       * The state of an Ice connection.
       */
      class ConnectionState<
        Name extends ConnectionStateName = ConnectionStateName
      > extends Ice.EnumBase<Name> {
        /**
         * The connection is being validated.
         */
        static ConnectionStateValidating: ConnectionState<
          \\"ConnectionStateValidating\\"
        >;

        /**
         * The connection is holding the reception of new messages.
         */
        static ConnectionStateHolding: ConnectionState<
          \\"ConnectionStateHolding\\"
        >;

        /**
         * The connection is active and can send and receive messages.
         */
        static ConnectionStateActive: ConnectionState<\\"ConnectionStateActive\\">;

        /**
         * The connection is being gracefully shutdown and waits for the
         * peer to close its end of the connection.
         */
        static ConnectionStateClosing: ConnectionState<
          \\"ConnectionStateClosing\\"
        >;

        /**
         * The connection is closed and waits for potential dispatch to be
         * finished before being destroyed and detached from the observer.
         */
        static ConnectionStateClosed: ConnectionState<\\"ConnectionStateClosed\\">;
      }

      /**
       * The connection observer interface to instrument Ice connections.
       */
      interface ConnectionObserver extends Observer {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;

        /**
         * Notification of sent bytes over the connection.
         *
         * @param num The number of bytes sent.
         */
        sentBytes(num: number): void;

        /**
         * Notification of received bytes over the connection.
         *
         * @param num The number of bytes received.
         */
        receivedBytes(num: number): void;
      }

      /**
       * The dispatch observer to instrument servant dispatch.
       */
      interface DispatchObserver extends Observer {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;

        /**
         * Notification of a user exception.
         */
        userException(): void;

        /**
         * Reply notification.
         *
         * @param size The size of the reply.
         */
        reply(size: number): void;
      }

      /**
       * The child invocation observer to instrument remote or collocated
       * invocations.
       */
      interface ChildInvocationObserver extends Observer {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;

        /**
         * Reply notification.
         *
         * @param size The size of the reply.
         */
        reply(size: number): void;
      }

      /**
       * The remote observer to instrument invocations that are sent over
       * the wire.
       */
      interface RemoteObserver extends ChildInvocationObserver {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;

        /**
         * Reply notification.
         *
         * @param size The size of the reply.
         */
        reply(size: number): void;
      }

      /**
       * The collocated observer to instrument invocations that are
       * collocated.
       */
      interface CollocatedObserver extends ChildInvocationObserver {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;

        /**
         * Reply notification.
         *
         * @param size The size of the reply.
         */
        reply(size: number): void;
      }

      /**
       * The invocation observer to instrument invocations on proxies. A
       * proxy invocation can either result in a collocated or remote
       * invocation. If it results in a remote invocation, a sub-observer is
       * requested for the remote invocation.
       */
      interface InvocationObserver extends Observer {
        /**
         * This method is called when the instrumented object is created
         * or when the observer is attached to an existing object.
         */
        attach(): void;

        /**
         * This method is called when the instrumented object is destroyed
         * and as a result the observer detached from the object.
         */
        detach(): void;

        /**
         * Notification of a failure.
         *
         * @param exceptionName The name of the exception.
         */
        failed(exceptionName: string): void;

        /**
         * Notification of the invocation being retried.
         */
        retried(): void;

        /**
         * Notification of a user exception.
         */
        userException(): void;

        /**
         * Get a remote observer for this invocation.
         *
         * @param con The connection information.
         *
         * @param endpt The connection endpoint.
         *
         * @param requestId The ID of the invocation.
         *
         * @param size The size of the invocation.
         *
         * @return The observer to instrument the remote invocation.
         */
        getRemoteObserver(
          con: ConnectionInfo | null,
          endpt: Endpoint,
          requestId: number,
          size: number
        ): RemoteObserver;

        /**
         * Get a collocated observer for this invocation.
         *
         * @param adapter The object adapter hosting the collocated Ice object.
         *
         * @param requestId The ID of the invocation.
         *
         * @param size The size of the invocation.
         *
         * @return The observer to instrument the collocated invocation.
         */
        getCollocatedObserver(
          adapter: ObjectAdapter,
          requestId: number,
          size: number
        ): CollocatedObserver;
      }

      /**
       * The observer updater interface. This interface is implemented by
       * the Ice run-time and an instance of this interface is provided by
       * the Ice communicator on initialization to the {@link
       * CommunicatorObserver} object set with the communicator
       * initialization data. The Ice communicator calls {@link
       * CommunicatorObserver#setObserverUpdater} to provide the observer
       * updater.
       *
       * This interface can be used by add-ins implementing the {@link
       * CommunicatorObserver} interface to update the observers of
       * connections and threads.
       */
      interface ObserverUpdater {
        /**
         * Update connection observers associated with each of the Ice
         * connection from the communicator and its object adapters.
         *
         * When called, this method goes through all the connections and
         * for each connection {@link CommunicatorObserver#getConnectionObserver}
         * is called. The implementation of getConnectionObserver has the
         * possibility to return an updated observer if necessary.
         */
        updateConnectionObservers(): void;

        /**
         * Update thread observers associated with each of the Ice thread
         * from the communicator and its object adapters.
         *
         * When called, this method goes through all the threads and for
         * each thread {@link CommunicatorObserver#getThreadObserver} is
         * called. The implementation of getThreadObserver has the
         * possibility to return an updated observer if necessary.
         */
        updateThreadObservers(): void;
      }

      /**
       * The communicator observer interface used by the Ice run-time to
       * obtain and update observers for its observable objects. This
       * interface should be implemented by add-ins that wish to observe Ice
       * objects in order to collect statistics. An instance of this
       * interface can be provided to the Ice run-time through the Ice
       * communicator initialization data.
       */
      interface CommunicatorObserver {
        /**
         * This method should return an observer for the given endpoint
         * information and connector. The Ice run-time calls this method
         * for each connection establishment attempt.
         *
         * @param endpt The endpoint.
         *
         * @param connector The description of the connector. For IP
         * transports, this is typically the IP address to connect to.
         *
         * @return The observer to instrument the connection establishment.
         */
        getConnectionEstablishmentObserver(
          endpt: Endpoint,
          connector: string
        ): Observer;

        /**
         * This method should return an observer for the given endpoint
         * information. The Ice run-time calls this method to resolve an
         * endpoint and obtain the list of connectors.
         *
         * For IP endpoints, this typically involves doing a DNS lookup to
         * obtain the IP addresses associated with the DNS name.
         *
         * @param endpt The endpoint.
         *
         * @return The observer to instrument the endpoint lookup.
         */
        getEndpointLookupObserver(endpt: Endpoint): Observer;

        /**
         * This method should return a connection observer for the given
         * connection. The Ice run-time calls this method for each new
         * connection and for all the Ice communicator connections when
         * {@link ObserverUpdater#updateConnectionObservers} is called.
         *
         * @param c The connection information.
         *
         * @param e The connection endpoint.
         *
         * @param s The state of the connection.
         *
         * @param o The old connection observer if one is already set or a
         * null reference otherwise.
         *
         * @return The connection observer to instrument the connection.
         */
        getConnectionObserver(
          c: ConnectionInfo | null,
          e: Endpoint,
          s: ConnectionState,
          o: ConnectionObserver
        ): ConnectionObserver;

        /**
         * This method should return a thread observer for the given
         * thread. The Ice run-time calls this method for each new thread
         * and for all the Ice communicator threads when
         * {@link ObserverUpdater#updateThreadObservers} is called.
         *
         * @param parent The parent of the thread.
         *
         * @param id The ID of the thread to observe.
         *
         * @param s The state of the thread.
         *
         * @param o The old thread observer if one is already set or a
         * null reference otherwise.
         *
         * @return The thread observer to instrument the thread.
         */
        getThreadObserver(
          parent: string,
          id: string,
          s: ThreadState,
          o: ThreadObserver
        ): ThreadObserver;

        /**
         * This method should return an invocation observer for the given
         * invocation. The Ice run-time calls this method for each new
         * invocation on a proxy.
         *
         * @param prx The proxy used for the invocation.
         *
         * @param operation The name of the invocation.
         *
         * @param ctx The context specified by the user.
         *
         * @return The invocation observer to instrument the invocation.
         */
        getInvocationObserver(
          prx: Ice.ObjectPrx | null,
          operation: string,
          ctx: Context
        ): InvocationObserver;

        /**
         * This method should return a dispatch observer for the given
         * dispatch. The Ice run-time calls this method each time it
         * receives an incoming invocation to be dispatched for an Ice
         * object.
         *
         * @param c The current object as provided to the Ice servant
         * dispatching the invocation.
         *
         * @param size The size of the dispatch.
         *
         * @return The dispatch observer to instrument the dispatch.
         */
        getDispatchObserver(c: Current, size: number): DispatchObserver;

        /**
         * The Ice run-time calls this method when the communicator is
         * initialized. The add-in implementing this interface can use
         * this object to get the Ice run-time to re-obtain observers for
         * observed objects.
         *
         * @param updater The observer updater object.
         */
        setObserverUpdater(updater: ObserverUpdater): void;
      }
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 22`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice { namespace Instrumentation {  } }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 23`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Identity\\";
import \\"../Ice/Version\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * This exception is raised when a failure occurs during initialization.
     */
    class InitializationException extends Ice.LocalException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception indicates that a failure occurred while initializing
     * a plug-in.
     */
    class PluginInitializationException extends Ice.LocalException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception is raised if a feature is requested that is not
     * supported with collocation optimization.
     */
    class CollocationOptimizationException extends Ice.LocalException {}

    /**
     * An attempt was made to register something more than once with
     * the Ice run time.
     *
     * This exception is raised if an attempt is made to register a
     * servant, servant locator, facet, value factory, plug-in, object
     * adapter, object, or user exception factory more than once for the
     * same ID.
     */
    class AlreadyRegisteredException extends Ice.LocalException {
      constructor(kindOfObject?: string, id?: string);

      /**
       * The kind of object that is registered already: \\"servant\\",
       * \\"servant locator\\", \\"value factory\\", \\"plug-in\\",
       * \\"object adapter\\", \\"object\\", or \\"user exception factory\\".
       */
      kindOfObject: string;

      /**
       * The ID (or name) of the object that is registered already.
       */
      id: string;
    }

    /**
     * An attempt was made to find or deregister something that is not
     * registered with the Ice run time or Ice locator.
     *
     * This exception is raised if an attempt is made to remove a servant,
     * servant locator, facet, value factory, plug-in, object adapter,
     * object, or user exception factory that is not currently registered.
     *
     * It's also raised if the Ice locator can't find an object or object
     * adapter when resolving an indirect proxy or when an object adapter
     * is activated.
     */
    class NotRegisteredException extends Ice.LocalException {
      constructor(kindOfObject?: string, id?: string);

      /**
       * The kind of object that could not be removed: \\"servant\\",
       * \\"servant locator\\", \\"value factory\\", \\"plug-in\\",
       * \\"object adapter\\", \\"object\\", or \\"user exception factory\\".
       */
      kindOfObject: string;

      /**
       * The ID (or name) of the object that could not be removed.
       */
      id: string;
    }

    /**
     * The operation can only be invoked with a twoway request.
     *
     * This exception is raised if an attempt is made to invoke an
     * operation with <tt>ice_oneway</tt>, <tt>ice_batchOneway</tt>, <tt>ice_datagram</tt>,
     * or <tt>ice_batchDatagram</tt> and the operation has a return value,
     * out-parameters, or an exception specification.
     */
    class TwowayOnlyException extends Ice.LocalException {
      constructor(operation?: string);

      /**
       * The name of the operation that was invoked.
       */
      operation: string;
    }

    /**
     * An attempt was made to clone a class that does not support
     * cloning.
     *
     * This exception is raised if <tt>ice_clone</tt> is called on
     * a class that is derived from an abstract Slice class (that is,
     * a class containing operations), and the derived class does not
     * provide an implementation of the <tt>ice_clone</tt> operation (C++ only).
     */
    class CloneNotImplementedException extends Ice.LocalException {}

    /**
     * This exception is raised if an operation call on a server raises an
     * unknown exception. For example, for C++, this exception is raised
     * if the server throws a C++ exception that is not directly or
     * indirectly derived from <tt>Ice::LocalException</tt> or
     * <tt>Ice::UserException</tt>.
     */
    class UnknownException extends Ice.LocalException {
      constructor(unknown?: string);

      /**
       * This field is set to the textual representation of the unknown
       * exception if available.
       */
      unknown: string;
    }

    /**
     * This exception is raised if an operation call on a server raises a
     * local exception. Because local exceptions are not transmitted by
     * the Ice protocol, the client receives all local exceptions raised
     * by the server as {@link UnknownLocalException}. The only exception to this
     * rule are all exceptions derived from {@link RequestFailedException},
     * which are transmitted by the Ice protocol even though they are
     * declared <tt>local</tt>.
     */
    class UnknownLocalException extends UnknownException {}

    /**
     * An operation raised an incorrect user exception.
     *
     * This exception is raised if an operation raises a
     * user exception that is not declared in the exception's
     * <tt>throws</tt> clause. Such undeclared exceptions are
     * not transmitted from the server to the client by the Ice
     * protocol, but instead the client just gets an
     * {@link UnknownUserException}. This is necessary in order to not violate
     * the contract established by an operation's signature: Only local
     * exceptions and user exceptions declared in the
     * <tt>throws</tt> clause can be raised.
     */
    class UnknownUserException extends UnknownException {}

    /**
     * This exception is raised if the Ice library version does not match
     * the version in the Ice header files.
     */
    class VersionMismatchException extends Ice.LocalException {}

    /**
     * This exception is raised if the {@link Communicator} has been destroyed.
     *
     * @see Communicator#destroy
     */
    class CommunicatorDestroyedException extends Ice.LocalException {}

    /**
     * This exception is raised if an attempt is made to use a deactivated
     * {@link ObjectAdapter}.
     *
     * @see ObjectAdapter#deactivate
     * @see Communicator#shutdown
     */
    class ObjectAdapterDeactivatedException extends Ice.LocalException {
      constructor(name?: string);

      /**
       * Name of the adapter.
       */
      name: string;
    }

    /**
     * This exception is raised if an {@link ObjectAdapter} cannot be activated.
     *
     * This happens if the {@link Locator} detects another active {@link ObjectAdapter} with
     * the same adapter id.
     */
    class ObjectAdapterIdInUseException extends Ice.LocalException {
      constructor(id?: string);

      /**
       * Adapter ID.
       */
      id: string;
    }

    /**
     * This exception is raised if no suitable endpoint is available.
     */
    class NoEndpointException extends Ice.LocalException {
      constructor(proxy?: string);

      /**
       * The stringified proxy for which no suitable endpoint is
       * available.
       */
      proxy: string;
    }

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint.
     */
    class EndpointParseException extends Ice.LocalException {
      constructor(str?: string);

      /**
       * Describes the failure and includes the string that could not be parsed.
       */
      str: string;
    }

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint selection type.
     */
    class EndpointSelectionTypeParseException extends Ice.LocalException {
      constructor(str?: string);

      /**
       * Describes the failure and includes the string that could not be parsed.
       */
      str: string;
    }

    /**
     * This exception is raised if there was an error while parsing a
     * version.
     */
    class VersionParseException extends Ice.LocalException {
      constructor(str?: string);

      /**
       * Describes the failure and includes the string that could not be parsed.
       */
      str: string;
    }

    /**
     * This exception is raised if there was an error while parsing a
     * stringified identity.
     */
    class IdentityParseException extends Ice.LocalException {
      constructor(str?: string);

      /**
       * Describes the failure and includes the string that could not be parsed.
       */
      str: string;
    }

    /**
     * This exception is raised if there was an error while parsing a
     * stringified proxy.
     */
    class ProxyParseException extends Ice.LocalException {
      constructor(str?: string);

      /**
       * Describes the failure and includes the string that could not be parsed.
       */
      str: string;
    }

    /**
     * This exception is raised if an illegal identity is encountered.
     */
    class IllegalIdentityException extends Ice.LocalException {
      constructor(id?: Identity);

      /**
       * The illegal identity.
       */
      id: Identity;
    }

    /**
     * This exception is raised to reject an illegal servant (typically
     * a null servant)
     */
    class IllegalServantException extends Ice.LocalException {
      constructor(reason?: string);

      /**
       * Describes why this servant is illegal.
       */
      reason: string;
    }

    /**
     * This exception is raised if a request failed. This exception, and
     * all exceptions derived from {@link RequestFailedException}, are
     * transmitted by the Ice protocol, even though they are declared
     * <tt>local</tt>.
     */
    class RequestFailedException extends Ice.LocalException {
      constructor(id?: Identity, facet?: string, operation?: string);

      id: Identity;
      facet: string;
      operation: string;
    }

    /**
     * This exception is raised if an object does not exist on the server,
     * that is, if no facets with the given identity exist.
     */
    class ObjectNotExistException extends RequestFailedException {}

    /**
     * This exception is raised if no facet with the given name exists,
     * but at least one facet with the given identity exists.
     */
    class FacetNotExistException extends RequestFailedException {}

    /**
     * This exception is raised if an operation for a given object does
     * not exist on the server. Typically this is caused by either the
     * client or the server using an outdated Slice specification.
     */
    class OperationNotExistException extends RequestFailedException {}

    /**
     * This exception is raised if a system error occurred in the server
     * or client process. There are many possible causes for such a system
     * exception. For details on the cause, {@link SyscallException#error}
     * should be inspected.
     */
    class SyscallException extends Ice.LocalException {
      constructor(error?: number);

      /**
       * The error number describing the system exception. For C++ and
       * Unix, this is equivalent to <tt>errno</tt>. For C++
       * and Windows, this is the value returned by
       * <tt>GetLastError()</tt> or
       * <tt>WSAGetLastError()</tt>.
       */
      error: number;
    }

    /**
     * This exception indicates socket errors.
     */
    class SocketException extends SyscallException {}

    /**
     * This exception indicates CFNetwork errors.
     */
    class CFNetworkException extends SocketException {
      constructor(error?: number, domain?: string);

      /**
       * The domain of the error.
       */
      domain: string;
    }

    /**
     * This exception indicates file errors.
     */
    class FileException extends SyscallException {
      constructor(error?: number, path?: string);

      path: string;
    }

    /**
     * This exception indicates connection failures.
     */
    class ConnectFailedException extends SocketException {}

    /**
     * This exception indicates a connection failure for which
     * the server host actively refuses a connection.
     */
    class ConnectionRefusedException extends ConnectFailedException {}

    /**
     * This exception indicates a lost connection.
     */
    class ConnectionLostException extends SocketException {}

    /**
     * This exception indicates a DNS problem. For details on the cause,
     * {@link DNSException#error} should be inspected.
     */
    class DNSException extends Ice.LocalException {
      constructor(error?: number, host?: string);

      /**
       * The error number describing the DNS problem. For C++ and Unix,
       * this is equivalent to <tt>h_errno</tt>. For C++ and
       * Windows, this is the value returned by
       * <tt>WSAGetLastError()</tt>.
       */
      error: number;

      /**
       * The host name that could not be resolved.
       */
      host: string;
    }

    /**
     * This exception indicates a request was interrupted.
     */
    class OperationInterruptedException extends Ice.LocalException {}

    /**
     * This exception indicates a timeout condition.
     */
    class TimeoutException extends Ice.LocalException {}

    /**
     * This exception indicates a connection establishment timeout condition.
     */
    class ConnectTimeoutException extends TimeoutException {}

    /**
     * This exception indicates a connection closure timeout condition.
     */
    class CloseTimeoutException extends TimeoutException {}

    /**
     * This exception indicates that a connection has been shut down because it has been
     * idle for some time.
     */
    class ConnectionTimeoutException extends TimeoutException {}

    /**
     * This exception indicates that an invocation failed because it timed
     * out.
     */
    class InvocationTimeoutException extends TimeoutException {}

    /**
     * This exception indicates that an asynchronous invocation failed
     * because it was canceled explicitly by the user.
     */
    class InvocationCanceledException extends Ice.LocalException {}

    /**
     * A generic exception base for all kinds of protocol error
     * conditions.
     */
    class ProtocolException extends Ice.LocalException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception indicates that a message did not start with the expected
     * magic number ('I', 'c', 'e', 'P').
     */
    class BadMagicException extends ProtocolException {
      constructor(reason?: string, badMagic?: ByteSeq);

      /**
       * A sequence containing the first four bytes of the incorrect message.
       */
      badMagic: ByteSeq;
    }

    /**
     * This exception indicates an unsupported protocol version.
     */
    class UnsupportedProtocolException extends ProtocolException {
      constructor(
        reason?: string,
        bad?: ProtocolVersion,
        supported?: ProtocolVersion
      );

      /**
       * The version of the unsupported protocol.
       */
      bad: ProtocolVersion;

      /**
       * The version of the protocol that is supported.
       */
      supported: ProtocolVersion;
    }

    /**
     * This exception indicates an unsupported data encoding version.
     */
    class UnsupportedEncodingException extends ProtocolException {
      constructor(
        reason?: string,
        bad?: EncodingVersion,
        supported?: EncodingVersion
      );

      /**
       * The version of the unsupported encoding.
       */
      bad: EncodingVersion;

      /**
       * The version of the encoding that is supported.
       */
      supported: EncodingVersion;
    }

    /**
     * This exception indicates that an unknown protocol message has been received.
     */
    class UnknownMessageException extends ProtocolException {}

    /**
     * This exception is raised if a message is received over a connection
     * that is not yet validated.
     */
    class ConnectionNotValidatedException extends ProtocolException {}

    /**
     * This exception indicates that a response for an unknown request ID has been
     * received.
     */
    class UnknownRequestIdException extends ProtocolException {}

    /**
     * This exception indicates that an unknown reply status has been received.
     */
    class UnknownReplyStatusException extends ProtocolException {}

    /**
     * This exception indicates that the connection has been gracefully shut down by the
     * server. The operation call that caused this exception has not been
     * executed by the server. In most cases you will not get this
     * exception, because the client will automatically retry the
     * operation call in case the server shut down the connection. However,
     * if upon retry the server shuts down the connection again, and the
     * retry limit has been reached, then this exception is propagated to
     * the application code.
     */
    class CloseConnectionException extends ProtocolException {}

    /**
     * This exception is raised by an operation call if the application
     * closes the connection locally using {@link Connection#close}.
     *
     * @see Connection#close
     */
    class ConnectionManuallyClosedException extends Ice.LocalException {
      constructor(graceful?: boolean);

      graceful: boolean;
    }

    /**
     * This exception indicates that a message size is less
     * than the minimum required size.
     */
    class IllegalMessageSizeException extends ProtocolException {}

    /**
     * This exception indicates a problem with compressing or uncompressing data.
     */
    class CompressionException extends ProtocolException {}

    /**
     * A datagram exceeds the configured size.
     *
     * This exception is raised if a datagram exceeds the configured send or receive buffer
     * size, or exceeds the maximum payload size of a UDP packet (65507 bytes).
     */
    class DatagramLimitException extends ProtocolException {}

    /**
     * This exception is raised for errors during marshaling or unmarshaling data.
     */
    class MarshalException extends ProtocolException {}

    /**
     * This exception is raised if inconsistent data is received while unmarshaling a proxy.
     */
    class ProxyUnmarshalException extends MarshalException {}

    /**
     * This exception is raised if an out-of-bounds condition occurs during unmarshaling.
     */
    class UnmarshalOutOfBoundsException extends MarshalException {}

    /**
     * This exception is raised if no suitable value factory was found during
     * unmarshaling of a Slice class instance.
     *
     * @see ValueFactory
     * @see Communicator#getValueFactoryManager
     * @see ValueFactoryManager#add
     * @see ValueFactoryManager#find
     */
    class NoValueFactoryException extends MarshalException {
      constructor(reason?: string, type?: string);

      /**
       * The Slice type ID of the class instance for which no
       * no factory could be found.
       */
      type: string;
    }

    /**
     * This exception is raised if the type of an unmarshaled Slice class instance does
     * not match its expected type.
     * This can happen if client and server are compiled with mismatched Slice
     * definitions or if a class of the wrong type is passed as a parameter
     * or return value using dynamic invocation. This exception can also be
     * raised if IceStorm is used to send Slice class instances and
     * an operation is subscribed to the wrong topic.
     */
    class UnexpectedObjectException extends MarshalException {
      constructor(reason?: string, type?: string, expectedType?: string);

      /**
       * The Slice type ID of the class instance that was unmarshaled.
       */
      type: string;

      /**
       * The Slice type ID that was expected by the receiving operation.
       */
      expectedType: string;
    }

    /**
     * This exception is raised when Ice receives a request or reply
     * message whose size exceeds the limit specified by the
     * <tt>Ice.MessageSizeMax</tt> property.
     */
    class MemoryLimitException extends MarshalException {}

    /**
     * This exception is raised when a string conversion to or from UTF-8
     * fails during marshaling or unmarshaling.
     */
    class StringConversionException extends MarshalException {}

    /**
     * This exception indicates a malformed data encapsulation.
     */
    class EncapsulationException extends MarshalException {}

    /**
     * This exception is raised if an unsupported feature is used. The
     * unsupported feature string contains the name of the unsupported
     * feature
     */
    class FeatureNotSupportedException extends Ice.LocalException {
      constructor(unsupportedFeature?: string);

      /**
       * The name of the unsupported feature.
       */
      unsupportedFeature: string;
    }

    /**
     * This exception indicates a failure in a security subsystem,
     * such as the IceSSL plug-in.
     */
    class SecurityException extends Ice.LocalException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception indicates that an attempt has been made to
     * change the connection properties of a fixed proxy.
     */
    class FixedProxyException extends Ice.LocalException {}

    /**
     * Indicates that the response to a request has already been sent;
     * re-dispatching such a request is not possible.
     */
    class ResponseSentException extends Ice.LocalException {}
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 24`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Identity\\";
import \\"../Ice/Process\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * This exception is raised if an adapter cannot be found.
     */
    class AdapterNotFoundException extends Ice.UserException {}

    /**
     * This exception is raised if the replica group provided by the
     * server is invalid.
     */
    class InvalidReplicaGroupIdException extends Ice.UserException {}

    /**
     * This exception is raised if a server tries to set endpoints for
     * an adapter that is already active.
     */
    class AdapterAlreadyActiveException extends Ice.UserException {}

    /**
     * This exception is raised if an object cannot be found.
     */
    class ObjectNotFoundException extends Ice.UserException {}

    /**
     * This exception is raised if a server cannot be found.
     */
    class ServerNotFoundException extends Ice.UserException {}

    /**
     * The Ice locator interface. This interface is used by clients to
     * lookup adapters and objects. It is also used by servers to get the
     * locator registry proxy.
     *
     * <p class=\\"Note\\">The {@link Locator} interface is intended to be used by
     * Ice internals and by locator implementations. Regular user code
     * should not attempt to use any functionality of this interface
     * directly.
     */
    abstract class Locator extends Ice.Object {
      /**
       * Find an object by identity and return a proxy that contains
       * the adapter ID or endpoints which can be used to access the
       * object.
       *
       * @param id The identity.
       *
       * @return The proxy, or null if the object is not active.
       *
       * @throws ObjectNotFoundException Raised if the object cannot
       * be found.
       */
      abstract findObjectById(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Find an adapter by id and return a proxy that contains
       * its endpoints.
       *
       * @param id The adapter id.
       *
       * @return The adapter proxy, or null if the adapter is not active.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot be
       * found.
       */
      abstract findAdapterById(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Get the locator registry.
       *
       * @return The locator registry.
       */
      abstract getRegistry(
        current: Ice.Current
      ): Ice.OperationResult<LocatorRegistryPrx | null>;
    }

    /**
     * The Ice locator interface. This interface is used by clients to
     * lookup adapters and objects. It is also used by servers to get the
     * locator registry proxy.
     *
     * <p class=\\"Note\\">The {@link Locator} interface is intended to be used by
     * Ice internals and by locator implementations. Regular user code
     * should not attempt to use any functionality of this interface
     * directly.
     */
    class LocatorPrx extends Ice.ObjectPrx {
      /**
       * Find an object by identity and return a proxy that contains
       * the adapter ID or endpoints which can be used to access the
       * object.
       *
       * @param id The identity.
       *
       * @return The proxy, or null if the object is not active.
       *
       * @throws ObjectNotFoundException Raised if the object cannot
       * be found.
       */
      findObjectById(
        id: Ice.Identity,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Find an adapter by id and return a proxy that contains
       * its endpoints.
       *
       * @param id The adapter id.
       *
       * @return The adapter proxy, or null if the adapter is not active.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot be
       * found.
       */
      findAdapterById(
        id: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Get the locator registry.
       *
       * @return The locator registry.
       */
      getRegistry(
        ctx?: Ice.Context
      ): Ice.AsyncResult<LocatorRegistryPrx | null>;
    }

    /**
     * The Ice locator registry interface. This interface is used by
     * servers to register adapter endpoints with the locator.
     *
     * <p class=\\"Note\\"> The {@link LocatorRegistry} interface is intended to be used
     * by Ice internals and by locator implementations. Regular user
     * code should not attempt to use any functionality of this interface
     * directly.
     */
    abstract class LocatorRegistry extends Ice.Object {
      /**
       * Set the adapter endpoints with the locator registry.
       *
       * @param id The adapter id.
       *
       * @param proxy The adapter proxy (a dummy direct proxy created
       * by the adapter). The direct proxy contains the adapter
       * endpoints.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot
       * be found, or if the locator only allows
       * registered adapters to set their active proxy and the
       * adapter is not registered with the locator.
       *
       * @throws AdapterAlreadyActiveException Raised if an adapter with the same
       * id is already active.
       */
      abstract setAdapterDirectProxy(
        id: string,
        proxy: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Set the adapter endpoints with the locator registry.
       *
       * @param adapterId The adapter id.
       *
       * @param replicaGroupId The replica group id.
       *
       * @param p The adapter proxy (a dummy direct proxy created
       * by the adapter). The direct proxy contains the adapter
       * endpoints.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot
       * be found, or if the locator only allows registered adapters to
       * set their active proxy and the adapter is not registered with
       * the locator.
       *
       * @throws AdapterAlreadyActiveException Raised if an adapter with the same
       * id is already active.
       *
       * @throws InvalidReplicaGroupIdException Raised if the given
       * replica group doesn't match the one registered with the
       * locator registry for this object adapter.
       */
      abstract setReplicatedAdapterDirectProxy(
        adapterId: string,
        replicaGroupId: string,
        p: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Set the process proxy for a server.
       *
       * @param id The server id.
       *
       * @param proxy The process proxy.
       *
       * @throws ServerNotFoundException Raised if the server cannot
       * be found.
       */
      abstract setServerProcessProxy(
        id: string,
        proxy: ProcessPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * The Ice locator registry interface. This interface is used by
     * servers to register adapter endpoints with the locator.
     *
     * <p class=\\"Note\\"> The {@link LocatorRegistry} interface is intended to be used
     * by Ice internals and by locator implementations. Regular user
     * code should not attempt to use any functionality of this interface
     * directly.
     */
    class LocatorRegistryPrx extends Ice.ObjectPrx {
      /**
       * Set the adapter endpoints with the locator registry.
       *
       * @param id The adapter id.
       *
       * @param proxy The adapter proxy (a dummy direct proxy created
       * by the adapter). The direct proxy contains the adapter
       * endpoints.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot
       * be found, or if the locator only allows
       * registered adapters to set their active proxy and the
       * adapter is not registered with the locator.
       *
       * @throws AdapterAlreadyActiveException Raised if an adapter with the same
       * id is already active.
       */
      setAdapterDirectProxy(
        id: string,
        proxy: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Set the adapter endpoints with the locator registry.
       *
       * @param adapterId The adapter id.
       *
       * @param replicaGroupId The replica group id.
       *
       * @param p The adapter proxy (a dummy direct proxy created
       * by the adapter). The direct proxy contains the adapter
       * endpoints.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot
       * be found, or if the locator only allows registered adapters to
       * set their active proxy and the adapter is not registered with
       * the locator.
       *
       * @throws AdapterAlreadyActiveException Raised if an adapter with the same
       * id is already active.
       *
       * @throws InvalidReplicaGroupIdException Raised if the given
       * replica group doesn't match the one registered with the
       * locator registry for this object adapter.
       */
      setReplicatedAdapterDirectProxy(
        adapterId: string,
        replicaGroupId: string,
        p: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Set the process proxy for a server.
       *
       * @param id The server id.
       *
       * @param proxy The process proxy.
       *
       * @throws ServerNotFoundException Raised if the server cannot
       * be found.
       */
      setServerProcessProxy(
        id: string,
        proxy: ProcessPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }

    /**
     * This inferface should be implemented by services implementing the
     * Ice::Locator interface. It should be advertised through an Ice
     * object with the identity \`Ice/LocatorFinder'. This allows clients
     * to retrieve the locator proxy with just the endpoint information of
     * the service.
     */
    abstract class LocatorFinder extends Ice.Object {
      /**
       * Get the locator proxy implemented by the process hosting this
       * finder object. The proxy might point to several replicas.
       *
       * @return The locator proxy.
       */
      abstract getLocator(
        current: Ice.Current
      ): Ice.OperationResult<LocatorPrx | null>;
    }

    /**
     * This inferface should be implemented by services implementing the
     * Ice::Locator interface. It should be advertised through an Ice
     * object with the identity \`Ice/LocatorFinder'. This allows clients
     * to retrieve the locator proxy with just the endpoint information of
     * the service.
     */
    class LocatorFinderPrx extends Ice.ObjectPrx {
      /**
       * Get the locator proxy implemented by the process hosting this
       * finder object. The proxy might point to several replicas.
       *
       * @return The locator proxy.
       */
      getLocator(ctx?: Ice.Context): Ice.AsyncResult<LocatorPrx | null>;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 25`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 26`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * The Ice message logger. Applications can provide their own logger
     * by implementing this interface and installing it in a communicator.
     */
    interface Logger {
      /**
       * Print a message. The message is printed literally, without
       * any decorations such as executable name or time stamp.
       *
       * @param message The message to log.
       */
      print(message: string): void;

      /**
       * Log a trace message.
       *
       * @param category The trace category.
       *
       * @param message The trace message to log.
       */
      trace(category: string, message: string): void;

      /**
       * Log a warning message.
       *
       * @param message The warning message to log.
       *
       * @see #error
       */
      warning(message: string): void;

      /**
       * Log an error message.
       *
       * @param message The error message to log.
       *
       * @see #warning
       */
      error(message: string): void;

      /**
       * Returns this logger's prefix.
       *
       * @return The prefix.
       */
      getPrefix(): string;

      cloneWithPrefix(prefix: string): Logger;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 27`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 28`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"../IceMX.ns\\" {
  namespace IceMX {
    /**
     * A dictionnary of strings to integers.
     */
    type StringIntDict = Map<string, number>;

    /**
     * The base class for metrics. A metrics object represents a
     * collection of measurements associated to a given a system.
     */
    class Metrics extends Ice.Value {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number
      );

      /**
       * The metrics identifier.
       */
      id: string;

      /**
       * The total number of objects that were observed by this metrics.
       */
      total: Ice.Long;

      /**
       * The current number of objects observed by this metrics.
       */
      current: number;

      /**
       * The sum of the lifetime of each observed objects. This does not
       * include the lifetime of objects which are currently observed.
       */
      totalLifetime: Ice.Long;

      /**
       * The number of failures observed.
       */
      failures: number;
    }

    /**
     * A structure to keep track of failures associated with a given
     * metrics.
     */
    class MetricsFailures implements Ice.Struct {
      constructor(id?: string, failures?: StringIntDict);

      /**
       * The identifier of the metrics object associated to the
       * failures.
       */
      id: string;

      /**
       * The failures observed for this metrics.
       */
      failures: StringIntDict;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of {@link MetricsFailures}.
     */
    type MetricsFailuresSeq = Array<MetricsFailures>;

    /**
     * A metrics map is a sequence of metrics. We use a sequence here
     * instead of a map because the ID of the metrics is already included
     * in the Metrics class and using sequences of metrics objects is more
     * efficient than using dictionaries since lookup is not necessary.
     */
    type MetricsMap = Array<Metrics | null>;

    /**
     * A metrics view is a dictionary of metrics map. The key of the
     * dictionary is the name of the metrics map.
     */
    type MetricsView = Map<string, MetricsMap>;

    /**
     * Raised if a metrics view cannot be found.
     */
    class UnknownMetricsView extends Ice.UserException {}

    /**
     * The metrics administrative facet interface. This interface allows
     * remote administrative clients to access metrics of an application
     * that enabled the Ice administrative facility and configured some
     * metrics views.
     */
    abstract class MetricsAdmin extends Ice.Object {
      /**
       * Get the names of enabled and disabled metrics.
       *
       * @param disabledViews The names of the disabled views.
       *
       * @return The name of the enabled views.
       */
      abstract getMetricsViewNames(
        current: Ice.Current
      ): Ice.OperationResult<[Ice.StringSeq, Ice.StringSeq]>;

      /**
       * Enables a metrics view.
       *
       * @param name The metrics view name.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      abstract enableMetricsView(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Disable a metrics view.
       *
       * @param name The metrics view name.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      abstract disableMetricsView(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Get the metrics objects for the given metrics view. This
       * returns a dictionnary of metric maps for each metrics class
       * configured with the view. The timestamp allows the client to
       * compute averages which are not dependent of the invocation
       * latency for this operation.
       *
       * @param view The name of the metrics view.
       *
       * @param timestamp The local time of the process when the metrics
       * object were retrieved.
       *
       * @return The metrics view data.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      abstract getMetricsView(
        view: string,
        current: Ice.Current
      ): Ice.OperationResult<[MetricsView, Ice.Long]>;

      /**
       * Get the metrics failures associated with the given view and map.
       *
       * @param view The name of the metrics view.
       *
       * @param map The name of the metrics map.
       *
       * @return The metrics failures associated with the map.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      abstract getMapMetricsFailures(
        view: string,
        map: string,
        current: Ice.Current
      ): Ice.OperationResult<MetricsFailuresSeq>;

      /**
       * Get the metrics failure associated for the given metrics.
       *
       * @param view The name of the metrics view.
       *
       * @param map The name of the metrics map.
       *
       * @param id The ID of the metrics.
       *
       * @return The metrics failures associated with the metrics.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      abstract getMetricsFailures(
        view: string,
        map: string,
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<MetricsFailures>;
    }

    /**
     * The metrics administrative facet interface. This interface allows
     * remote administrative clients to access metrics of an application
     * that enabled the Ice administrative facility and configured some
     * metrics views.
     */
    class MetricsAdminPrx extends Ice.ObjectPrx {
      /**
       * Get the names of enabled and disabled metrics.
       *
       * @param disabledViews The names of the disabled views.
       *
       * @return The name of the enabled views.
       */
      getMetricsViewNames(
        ctx?: Ice.Context
      ): Ice.AsyncResult<[Ice.StringSeq, Ice.StringSeq]>;

      /**
       * Enables a metrics view.
       *
       * @param name The metrics view name.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      enableMetricsView(name: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Disable a metrics view.
       *
       * @param name The metrics view name.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      disableMetricsView(
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Get the metrics objects for the given metrics view. This
       * returns a dictionnary of metric maps for each metrics class
       * configured with the view. The timestamp allows the client to
       * compute averages which are not dependent of the invocation
       * latency for this operation.
       *
       * @param view The name of the metrics view.
       *
       * @param timestamp The local time of the process when the metrics
       * object were retrieved.
       *
       * @return The metrics view data.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      getMetricsView(
        view: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<[MetricsView, Ice.Long]>;

      /**
       * Get the metrics failures associated with the given view and map.
       *
       * @param view The name of the metrics view.
       *
       * @param map The name of the metrics map.
       *
       * @return The metrics failures associated with the map.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      getMapMetricsFailures(
        view: string,
        map: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<MetricsFailuresSeq>;

      /**
       * Get the metrics failure associated for the given metrics.
       *
       * @param view The name of the metrics view.
       *
       * @param map The name of the metrics map.
       *
       * @param id The ID of the metrics.
       *
       * @return The metrics failures associated with the metrics.
       *
       * @throws UnknownMetricsView Raised if the metrics view cannot be
       * found.
       */
      getMetricsFailures(
        view: string,
        map: string,
        id: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<MetricsFailures>;
    }

    /**
     * Provides information on the number of threads currently in use and
     * their activity.
     */
    class ThreadMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        inUseForIO?: number,
        inUseForUser?: number,
        inUseForOther?: number
      );

      /**
       * The number of threads which are currently performing socket
       * read or writes.
       */
      inUseForIO: number;

      /**
       * The number of threads which are currently calling user code
       * (servant dispatch, AMI callbacks, etc).
       */
      inUseForUser: number;

      /**
       * The number of threads which are currently performing other
       * activities. These are all other that are not counted with
       * {@link #inUseForUser} or {@link #inUseForIO}, such as DNS
       * lookups, garbage collection).
       */
      inUseForOther: number;
    }

    /**
     * Provides information on servant dispatch.
     */
    class DispatchMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        userException?: number,
        size?: Ice.Long,
        replySize?: Ice.Long
      );

      /**
       * The number of dispatch that failed with a user exception.
       */
      userException: number;

      /**
       * The size of the dispatch. This corresponds to the size of the
       * marshalled input parameters.
       */
      size: Ice.Long;

      /**
       * The size of the dispatch reply. This corresponds to the size of
       * the marshalled output and return parameters.
       */
      replySize: Ice.Long;
    }

    /**
     * Provides information on child invocations. A child invocation is
     * either remote (sent over an Ice connection) or collocated. An
     * invocation can have multiple child invocation if it is
     * retried. Child invocation metrics are embedded within {@link
     * InvocationMetrics}.
     */
    class ChildInvocationMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        size?: Ice.Long,
        replySize?: Ice.Long
      );

      /**
       * The size of the invocation. This corresponds to the size of the
       * marshalled input parameters.
       */
      size: Ice.Long;

      /**
       * The size of the invocation reply. This corresponds to the size
       * of the marshalled output and return parameters.
       */
      replySize: Ice.Long;
    }

    /**
     * Provides information on invocations that are collocated. Collocated
     * metrics are embedded within {@link InvocationMetrics}.
     */
    class CollocatedMetrics extends ChildInvocationMetrics {}

    /**
     * Provides information on invocations that are specifically sent over
     * Ice connections. Remote metrics are embedded within {@link
     * InvocationMetrics}.
     */
    class RemoteMetrics extends ChildInvocationMetrics {}

    /**
     * Provide measurements for proxy invocations. Proxy invocations can
     * either be sent over the wire or be collocated.
     */
    class InvocationMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        retry?: number,
        userException?: number,
        remotes?: MetricsMap,
        collocated?: MetricsMap
      );

      /**
       * The number of retries for the invocation(s).
       */
      retry: number;

      /**
       * The number of invocations that failed with a user exception.
       */
      userException: number;

      /**
       * The remote invocation metrics map.
       *
       * @see RemoteMetrics
       */
      remotes: MetricsMap;

      /**
       * The collocated invocation metrics map.
       *
       * @see CollocatedMetrics
       */
      collocated: MetricsMap;
    }

    /**
     * Provides information on the data sent and received over Ice
     * connections.
     */
    class ConnectionMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        receivedBytes?: Ice.Long,
        sentBytes?: Ice.Long
      );

      /**
       * The number of bytes received by the connection.
       */
      receivedBytes: Ice.Long;

      /**
       * The number of bytes sent by the connection.
       */
      sentBytes: Ice.Long;
    }
  }
}
export { IceMX } from \\"../IceMX.ns\\";
"
`;

exports[`generate typings built-in slices 29`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/CommunicatorF\\";
import \\"../Ice/ServantLocatorF\\";
import \\"../Ice/Locator\\";
import \\"../Ice/Identity\\";
import \\"../Ice/FacetMap\\";
import \\"../Ice/Endpoint\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * The object adapter provides an up-call interface from the Ice
     * run time to the implementation of Ice objects.
     *
     * The object adapter is responsible for receiving requests
     * from endpoints, and for mapping between servants, identities, and
     * proxies.
     *
     * @see Communicator
     * @see ServantLocator
     */
    interface ObjectAdapter {
      /**
       * Get the name of this object adapter.
       *
       * @return This object adapter's name.
       */
      getName(): string;

      /**
       * Get the communicator this object adapter belongs to.
       *
       * @return This object adapter's communicator.
       *
       * @see Communicator
       */
      getCommunicator(): Communicator;

      /**
       * Activate all endpoints that belong to this object adapter.
       * After activation, the object adapter can dispatch requests
       * received through its endpoints.
       *
       * @see #hold
       * @see #deactivate
       */
      activate(): void;

      /**
       * Temporarily hold receiving and dispatching requests. The object
       * adapter can be reactivated with the {@link #activate} operation.
       *
       * <p class=\\"Note\\"> Holding is not immediate, i.e., after {@link #hold}
       * returns, the object adapter might still be active for some
       * time. You can use {@link #waitForHold} to wait until holding is
       * complete.
       *
       * @see #activate
       * @see #deactivate
       * @see #waitForHold
       */
      hold(): void;

      /**
       * Wait until the object adapter holds requests. Calling {@link #hold}
       * initiates holding of requests, and {@link #waitForHold} only returns
       * when holding of requests has been completed.
       *
       * @see #hold
       * @see #waitForDeactivate
       * @see Communicator#waitForShutdown
       */
      waitForHold(): void;

      /**
       * Deactivate all endpoints that belong to this object adapter.
       * After deactivation, the object adapter stops receiving
       * requests through its endpoints. Object adapters that have been
       * deactivated must not be reactivated again, and cannot be used
       * otherwise. Attempts to use a deactivated object adapter raise
       * {@link ObjectAdapterDeactivatedException} however, attempts to
       * {@link #deactivate} an already deactivated object adapter are
       * ignored and do nothing. Once deactivated, it is possible to
       * destroy the adapter to clean up resources and then create and
       * activate a new adapter with the same name.
       *
       * <p class=\\"Note\\"> After {@link #deactivate} returns, no new requests
       * are processed by the object adapter. However, requests that
       * have been started before {@link #deactivate} was called might
       * still be active. You can use {@link #waitForDeactivate} to wait
       * for the completion of all requests for this object adapter.
       *
       * @see #activate
       * @see #hold
       * @see #waitForDeactivate
       * @see Communicator#shutdown
       */
      deactivate(): void;

      /**
       * Wait until the object adapter has deactivated. Calling
       * {@link #deactivate} initiates object adapter deactivation, and
       * {@link #waitForDeactivate} only returns when deactivation has
       * been completed.
       *
       * @see #deactivate
       * @see #waitForHold
       * @see Communicator#waitForShutdown
       */
      waitForDeactivate(): void;

      /**
       * Check whether object adapter has been deactivated.
       *
       * @return Whether adapter has been deactivated.
       *
       * @see Communicator#shutdown
       */
      isDeactivated(): boolean;

      /**
       * Destroys the object adapter and cleans up all resources held by
       * the object adapter. If the object adapter has not yet been
       * deactivated, destroy implicitly initiates the deactivation
       * and waits for it to finish. Subsequent calls to destroy are
       * ignored. Once destroy has returned, it is possible to create
       * another object adapter with the same name.
       *
       * @see #deactivate
       * @see #waitForDeactivate
       * @see Communicator#destroy
       */
      destroy(): void;

      /**
       * Add a servant to this object adapter's Active Servant Map. Note
       * that one servant can implement several Ice objects by registering
       * the servant with multiple identities. Adding a servant with an
       * identity that is in the map already throws {@link AlreadyRegisteredException}.
       *
       * @param servant The servant to add.
       *
       * @param id The identity of the Ice object that is implemented by
       * the servant.
       *
       * @return A proxy that matches the given identity and this object
       * adapter.
       *
       * @see Identity
       * @see #addFacet
       * @see #addWithUUID
       * @see #remove
       * @see #find
       */
      add(servant: Ice.Object | null, id: Identity): Ice.ObjectPrx | null;

      /**
       * Like {@link #add}, but with a facet. Calling <tt>add(servant, id)</tt>
       * is equivalent to calling {@link #addFacet} with an empty facet.
       *
       * @param servant The servant to add.
       *
       * @param id The identity of the Ice object that is implemented by
       * the servant.
       *
       * @param facet The facet. An empty facet means the default facet.
       *
       * @return A proxy that matches the given identity, facet, and
       * this object adapter.
       *
       * @see Identity
       * @see #add
       * @see #addFacetWithUUID
       * @see #removeFacet
       * @see #findFacet
       */
      addFacet(
        servant: Ice.Object | null,
        id: Identity,
        facet: string
      ): Ice.ObjectPrx | null;

      /**
       * Add a servant to this object adapter's Active Servant Map,
       * using an automatically generated UUID as its identity. Note that
       * the generated UUID identity can be accessed using the proxy's
       * <tt>ice_getIdentity</tt> operation.
       *
       * @param servant The servant to add.
       *
       * @return A proxy that matches the generated UUID identity and
       * this object adapter.
       *
       * @see Identity
       * @see #add
       * @see #addFacetWithUUID
       * @see #remove
       * @see #find
       */
      addWithUUID(servant: Ice.Object | null): Ice.ObjectPrx | null;

      /**
       * Like {@link #addWithUUID}, but with a facet. Calling
       * <tt>addWithUUID(servant)</tt> is equivalent to calling
       * {@link #addFacetWithUUID} with an empty facet.
       *
       * @param servant The servant to add.
       *
       * @param facet The facet. An empty facet means the default
       * facet.
       *
       * @return A proxy that matches the generated UUID identity,
       * facet, and this object adapter.
       *
       * @see Identity
       * @see #addFacet
       * @see #addWithUUID
       * @see #removeFacet
       * @see #findFacet
       */
      addFacetWithUUID(
        servant: Ice.Object | null,
        facet: string
      ): Ice.ObjectPrx | null;

      /**
       * Add a default servant to handle requests for a specific
       * category. Adding a default servant for a category for
       * which a default servant is already registered throws
       * {@link AlreadyRegisteredException}. To dispatch operation
       * calls on servants, the object adapter tries to find a servant
       * for a given Ice object identity and facet in the following
       * order:
       *
       * <ol>
       *
       * <li>The object adapter tries to find a servant for the identity
       * and facet in the Active Servant Map.</li>
       *
       * <li>If no servant has been found in the Active Servant Map, the
       * object adapter tries to find a default servant for the category
       * component of the identity.</li>
       *
       * <li>If no servant has been found by any of the preceding steps,
       * the object adapter tries to find a default servant for an empty
       * category, regardless of the category contained in the identity.</li>
       *
       * <li>If no servant has been found by any of the preceding steps,
       * the object adapter gives up and the caller receives
       * {@link ObjectNotExistException} or {@link FacetNotExistException}.</li>
       *
       * </ol>
       *
       * @param servant The default servant.
       *
       * @param category The category for which the default servant is
       * registered. An empty category means it will handle all categories.
       *
       * @see #removeDefaultServant
       * @see #findDefaultServant
       */
      addDefaultServant(servant: Ice.Object | null, category: string): void;

      /**
       * Remove a servant (that is, the default facet) from the object
       * adapter's Active Servant Map.
       *
       * @param id The identity of the Ice object that is implemented by
       * the servant. If the servant implements multiple Ice objects,
       * {@link #remove} has to be called for all those Ice objects.
       * Removing an identity that is not in the map throws
       * {@link NotRegisteredException}.
       *
       * @return The removed servant.
       *
       * @see Identity
       * @see #add
       * @see #addWithUUID
       */
      remove(id: Identity): Ice.Object | null;

      /**
       * Like {@link #remove}, but with a facet. Calling <tt>remove(id)</tt>
       * is equivalent to calling {@link #removeFacet} with an empty facet.
       *
       * @param id The identity of the Ice object that is implemented by
       * the servant.
       *
       * @param facet The facet. An empty facet means the default facet.
       *
       * @return The removed servant.
       *
       * @see Identity
       * @see #addFacet
       * @see #addFacetWithUUID
       */
      removeFacet(id: Identity, facet: string): Ice.Object | null;

      /**
       * Remove all facets with the given identity from the Active
       * Servant Map. The operation completely removes the Ice object,
       * including its default facet. Removing an identity that
       * is not in the map throws {@link NotRegisteredException}.
       *
       * @param id The identity of the Ice object to be removed.
       *
       * @return A collection containing all the facet names and
       * servants of the removed Ice object.
       *
       * @see #remove
       * @see #removeFacet
       */
      removeAllFacets(id: Identity): FacetMap;

      /**
       * Remove the default servant for a specific category. Attempting
       * to remove a default servant for a category that is not
       * registered throws {@link NotRegisteredException}.
       *
       * @param category The category of the default servant to remove.
       *
       * @return The default servant.
       *
       * @see #addDefaultServant
       * @see #findDefaultServant
       */
      removeDefaultServant(category: string): Ice.Object | null;

      /**
       * Look up a servant in this object adapter's Active Servant Map
       * by the identity of the Ice object it implements.
       *
       * <p class=\\"Note\\">This operation only tries to look up a servant in
       * the Active Servant Map. It does not attempt to find a servant
       * by using any installed {@link ServantLocator}.
       *
       * @param id The identity of the Ice object for which the servant
       * should be returned.
       *
       * @return The servant that implements the Ice object with the
       * given identity, or null if no such servant has been found.
       *
       * @see Identity
       * @see #findFacet
       * @see #findByProxy
       */
      find(id: Identity): Ice.Object | null;

      /**
       * Like {@link #find}, but with a facet. Calling <tt>find(id)</tt>
       * is equivalent to calling {@link #findFacet} with an empty
       * facet.
       *
       * @param id The identity of the Ice object for which the
       * servant should be returned.
       *
       * @param facet The facet. An empty facet means the default
       * facet.
       *
       * @return The servant that implements the Ice object with the
       * given identity and facet, or null if no such servant has been
       * found.
       *
       * @see Identity
       * @see #find
       * @see #findByProxy
       */
      findFacet(id: Identity, facet: string): Ice.Object | null;

      /**
       * Find all facets with the given identity in the Active Servant
       * Map.
       *
       * @param id The identity of the Ice object for which the facets
       * should be returned.
       *
       * @return A collection containing all the facet names and
       * servants that have been found, or an empty map if there is no
       * facet for the given identity.
       *
       * @see #find
       * @see #findFacet
       */
      findAllFacets(id: Identity): FacetMap;

      /**
       * Look up a servant in this object adapter's Active Servant Map,
       * given a proxy.
       *
       * <p class=\\"Note\\">This operation only tries to lookup a servant in
       * the Active Servant Map. It does not attempt to find a servant
       * by using any installed {@link ServantLocator}.
       *
       * @param proxy The proxy for which the servant should be returned.
       *
       * @return The servant that matches the proxy, or null if no such
       * servant has been found.
       *
       * @see #find
       * @see #findFacet
       */
      findByProxy(proxy: Ice.ObjectPrx | null): Ice.Object | null;

      /**
       * Add a Servant Locator to this object adapter. Adding a servant
       * locator for a category for which a servant locator is already
       * registered throws {@link AlreadyRegisteredException}. To dispatch
       * operation calls on servants, the object adapter tries to find a
       * servant for a given Ice object identity and facet in the
       * following order:
       *
       * <ol>
       *
       * <li>The object adapter tries to find a servant for the identity
       * and facet in the Active Servant Map.</li>
       *
       * <li>If no servant has been found in the Active Servant Map,
       * the object adapter tries to find a servant locator for the
       * category component of the identity. If a locator is found, the
       * object adapter tries to find a servant using this locator.</li>
       *
       * <li>If no servant has been found by any of the preceding steps,
       * the object adapter tries to find a locator for an empty category,
       * regardless of the category contained in the identity. If a
       * locator is found, the object adapter tries to find a servant
       * using this locator.</li>
       *
       * <li>If no servant has been found by any of the preceding steps,
       * the object adapter gives up and the caller receives
       * {@link ObjectNotExistException} or {@link FacetNotExistException}.</li>
       *
       * </ol>
       *
       * <p class=\\"Note\\">Only one locator for the empty category can be
       * installed.
       *
       * @param locator The locator to add.
       *
       * @param category The category for which the Servant Locator can
       * locate servants, or an empty string if the Servant Locator does
       * not belong to any specific category.
       *
       * @see Identity
       * @see #removeServantLocator
       * @see #findServantLocator
       * @see ServantLocator
       */
      addServantLocator(locator: ServantLocator, category: string): void;

      /**
       * Remove a Servant Locator from this object adapter.
       *
       * @param category The category for which the Servant Locator can
       * locate servants, or an empty string if the Servant Locator does
       * not belong to any specific category.
       *
       * @return The Servant Locator, or throws {@link NotRegisteredException}
       * if no Servant Locator was found for the given category.
       *
       * @see Identity
       * @see #addServantLocator
       * @see #findServantLocator
       * @see ServantLocator
       */
      removeServantLocator(category: string): ServantLocator;

      /**
       * Find a Servant Locator installed with this object adapter.
       *
       * @param category The category for which the Servant Locator can
       * locate servants, or an empty string if the Servant Locator does
       * not belong to any specific category.
       *
       * @return The Servant Locator, or null if no Servant Locator was
       * found for the given category.
       *
       * @see Identity
       * @see #addServantLocator
       * @see #removeServantLocator
       * @see ServantLocator
       */
      findServantLocator(category: string): ServantLocator;

      /**
       * Find the default servant for a specific category.
       *
       * @param category The category of the default servant to find.
       *
       * @return The default servant or null if no default servant was
       * registered for the category.
       *
       * @see #addDefaultServant
       * @see #removeDefaultServant
       */
      findDefaultServant(category: string): Ice.Object | null;

      /**
       * Create a proxy for the object with the given identity. If this
       * object adapter is configured with an adapter id, the return
       * value is an indirect proxy that refers to the adapter id. If
       * a replica group id is also defined, the return value is an
       * indirect proxy that refers to the replica group id. Otherwise,
       * if no adapter id is defined, the return value is a direct
       * proxy containing this object adapter's published endpoints.
       *
       * @param id The object's identity.
       *
       * @return A proxy for the object with the given identity.
       *
       * @see Identity
       */
      createProxy(id: Identity): Ice.ObjectPrx | null;

      /**
       * Create a direct proxy for the object with the given identity.
       * The returned proxy contains this object adapter's published
       * endpoints.
       *
       * @param id The object's identity.
       *
       * @return A proxy for the object with the given identity.
       *
       * @see Identity
       */
      createDirectProxy(id: Identity): Ice.ObjectPrx | null;

      /**
       * Create an indirect proxy for the object with the given identity.
       * If this object adapter is configured with an adapter id, the
       * return value refers to the adapter id. Otherwise, the return
       * value contains only the object identity.
       *
       * @param id The object's identity.
       *
       * @return A proxy for the object with the given identity.
       *
       * @see Identity
       */
      createIndirectProxy(id: Identity): Ice.ObjectPrx | null;

      /**
       * Set an Ice locator for this object adapter. By doing so, the
       * object adapter will register itself with the locator registry
       * when it is activated for the first time. Furthermore, the proxies
       * created by this object adapter will contain the adapter identifier
       * instead of its endpoints. The adapter identifier must be configured
       * using the AdapterId property.
       *
       * @param loc The locator used by this object adapter.
       *
       * @see #createDirectProxy
       * @see Locator
       * @see LocatorRegistry
       */
      setLocator(loc: LocatorPrx | null): void;

      /**
       * Get the Ice locator used by this object adapter.
       *
       * @return  The locator used by this object adapter, or null if no locator is
       * used by this object adapter.
       *
       * @see Locator
       * @see #setLocator
       */
      getLocator(): LocatorPrx | null;

      /**
       * Get the set of endpoints configured with this object adapter.
       *
       * @return The set of endpoints.
       *
       * @see Endpoint
       */
      getEndpoints(): EndpointSeq;

      /**
       * Refresh the set of published endpoints. The run time re-reads
       * the PublishedEndpoints property if it is set and re-reads the
       * list of local interfaces if the adapter is configured to listen
       * on all endpoints. This operation is useful to refresh the endpoint
       * information that is published in the proxies that are created by
       * an object adapter if the network interfaces used by a host changes.
       */
      refreshPublishedEndpoints(): void;

      /**
       * Get the set of endpoints that proxies created by this object
       * adapter will contain.
       *
       * @return The set of published endpoints.
       *
       * @see #refreshPublishedEndpoints
       * @see Endpoint
       */
      getPublishedEndpoints(): EndpointSeq;

      /**
       * Set of the endpoints that proxies created by this object
       * adapter will contain.
       *
       * @param newEndpoints The new set of endpoints that the object adapter will embed in proxies.
       *
       * @see #refreshPublishedEndpoints
       * @see Endpoint
       */
      setPublishedEndpoints(newEndpoints: EndpointSeq): void;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 30`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 31`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A factory for objects. Object factories are used when receiving \\"objects by value\\".
     * An object factory must be implemented by the application writer and registered
     * with the communicator.
     */
    interface ObjectFactory {
      /**
       * Create a new object for a given object type. The type is the
       * absolute Slice type id, i.e., the id relative to the
       * unnamed top-level Slice module. For example, the absolute
       * Slice type id for interfaces of type <tt>Bar</tt> in the module
       * <tt>Foo</tt> is <tt>::Foo::Bar</tt>.
       *
       * <p class=\\"Note\\">The leading \\"<tt>::</tt>\\" is required.
       *
       * @param type The object type.
       *
       * @return The object created for the given type, or nil if the
       * factory is unable to create the object.
       */
      create(type: string): Ice.Value | null;

      /**
       * Called when the factory is removed from the communicator, or if
       * the communicator is destroyed.
       *
       * @see Communicator#destroy
       */
      destroy(): void;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 32`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/LoggerF\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A communicator plug-in. A plug-in generally adds a feature to a
     * communicator, such as support for a protocol.
     *
     * The communicator loads its plug-ins in two stages: the first stage
     * creates the plug-ins, and the second stage invokes {@link Plugin#initialize} on
     * each one.
     */
    interface Plugin {
      /**
       * Perform any necessary initialization steps.
       */
      initialize(): void;

      /**
       * Called when the communicator is being destroyed.
       */
      destroy(): void;
    }

    /**
     * Each communicator has a plug-in manager to administer the set of
     * plug-ins.
     */
    interface PluginManager {
      /**
       * Initialize the configured plug-ins. The communicator automatically initializes
       * the plug-ins by default, but an application may need to interact directly with
       * a plug-in prior to initialization. In this case, the application must set
       * <tt>Ice.InitPlugins=0</tt> and then invoke {@link #initializePlugins}
       * manually. The plug-ins are initialized in the order in which they are loaded.
       * If a plug-in raises an exception during initialization, the communicator
       * invokes destroy on the plug-ins that have already been initialized.
       *
       * @throws InitializationException Raised if the plug-ins have already been initialized.
       */
      initializePlugins(): void;

      /**
       * Get a list of plugins installed.
       *
       * @return The names of the plugins installed.
       *
       * @see #getPlugin
       */
      getPlugins(): StringSeq;

      /**
       * Obtain a plug-in by name.
       *
       * @param name The plug-in's name.
       *
       * @return The plug-in.
       *
       * @throws NotRegisteredException Raised if no plug-in is found with the given name.
       */
      getPlugin(name: string): Plugin;

      /**
       * Install a new plug-in.
       *
       * @param name The plug-in's name.
       *
       * @param pi The plug-in.
       *
       * @throws AlreadyRegisteredException Raised if a plug-in already exists with the given name.
       */
      addPlugin(name: string, pi: Plugin): void;

      /**
       * Called when the communicator is being destroyed.
       */
      destroy(): void;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 33`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 34`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * An administrative interface for process management. Managed servers must
     * implement this interface.
     *
     * <p class=\\"Note\\">A servant implementing this interface is a potential target
     * for denial-of-service attacks, therefore proper security precautions
     * should be taken. For example, the servant can use a UUID to make its
     * identity harder to guess, and be registered in an object adapter with
     * a secured endpoint.
     */
    abstract class Process extends Ice.Object {
      /**
       * Initiate a graceful shut-down.
       *
       * @see Communicator#shutdown
       */
      abstract shutdown(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Write a message on the process' stdout or stderr.
       *
       * @param message The message.
       *
       * @param fd 1 for stdout, 2 for stderr.
       */
      abstract writeMessage(
        message: string,
        fd: number,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * An administrative interface for process management. Managed servers must
     * implement this interface.
     *
     * <p class=\\"Note\\">A servant implementing this interface is a potential target
     * for denial-of-service attacks, therefore proper security precautions
     * should be taken. For example, the servant can use a UUID to make its
     * identity harder to guess, and be registered in an object adapter with
     * a secured endpoint.
     */
    class ProcessPrx extends Ice.ObjectPrx {
      /**
       * Initiate a graceful shut-down.
       *
       * @see Communicator#shutdown
       */
      shutdown(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Write a message on the process' stdout or stderr.
       *
       * @param message The message.
       *
       * @param fd 1 for stdout, 2 for stderr.
       */
      writeMessage(
        message: string,
        fd: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 35`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 36`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/PropertiesAdmin\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A property set used to configure Ice and Ice applications.
     * Properties are key/value pairs, with both keys and values
     * being strings. By convention, property keys should have the form
     * <em>application-name</em>\\\\[.<em>category</em>\\\\[.<em>sub-category</em>]].<em>name</em>.
     */
    interface Properties {
      /**
       * Get a property by key. If the property is not set, an empty
       * string is returned.
       *
       * @param key The property key.
       *
       * @return The property value.
       *
       * @see #setProperty
       */
      getProperty(key: string): string;

      /**
       * Get a property by key. If the property is not set, the
       * given default value is returned.
       *
       * @param key The property key.
       *
       * @param value The default value to use if the property does not
       * exist.
       *
       * @return The property value or the default value.
       *
       * @see #setProperty
       */
      getPropertyWithDefault(key: string, value: string): string;

      /**
       * Get a property as an integer. If the property is not set, 0
       * is returned.
       *
       * @param key The property key.
       *
       * @return The property value interpreted as an integer.
       *
       * @see #setProperty
       */
      getPropertyAsInt(key: string): number;

      /**
       * Get a property as an integer. If the property is not set, the
       * given default value is returned.
       *
       * @param key The property key.
       *
       * @param value The default value to use if the property does not
       * exist.
       *
       * @return The property value interpreted as an integer, or the
       * default value.
       *
       * @see #setProperty
       */
      getPropertyAsIntWithDefault(key: string, value: number): number;

      /**
       * Get a property as a list of strings. The strings must be
       * separated by whitespace or comma. If the property is not set,
       * an empty list is returned. The strings in the list can contain
       * whitespace and commas if they are enclosed in single or double
       * quotes. If quotes are mismatched, an empty list is returned.
       * Within single quotes or double quotes, you can escape the
       * quote in question with \\\\, e.g. O'Reilly can be written as
       * O'Reilly, \\"O'Reilly\\" or 'O\\\\'Reilly'.
       *
       * @param key The property key.
       *
       * @return The property value interpreted as a list of strings.
       *
       * @see #setProperty
       */
      getPropertyAsList(key: string): StringSeq;

      /**
       * Get a property as a list of strings.  The strings must be
       * separated by whitespace or comma. If the property is not set,
       * the default list is returned. The strings in the list can contain
       * whitespace and commas if they are enclosed in single or double
       * quotes. If quotes are mismatched, the default list is returned.
       * Within single quotes or double quotes, you can escape the
       * quote in question with \\\\, e.g. O'Reilly can be written as
       * O'Reilly, \\"O'Reilly\\" or 'O\\\\'Reilly'.
       *
       * @param key The property key.
       *
       * @param value The default value to use if the property is not set.
       *
       * @return The property value interpreted as list of strings, or the
       * default value.
       *
       * @see #setProperty
       */
      getPropertyAsListWithDefault(key: string, value: StringSeq): StringSeq;

      /**
       * Get all properties whose keys begins with
       * <em>prefix</em>. If
       * <em>prefix</em> is an empty string,
       * then all properties are returned.
       *
       * @param prefix The prefix to search for (empty string if none).
       * @return The matching property set.
       */
      getPropertiesForPrefix(prefix: string): PropertyDict;

      /**
       * Set a property. To unset a property, set it to
       * the empty string.
       *
       * @param key The property key.
       * @param value The property value.
       *
       * @see #getProperty
       */
      setProperty(key: string, value: string): void;

      /**
       * Get a sequence of command-line options that is equivalent to
       * this property set. Each element of the returned sequence is
       * a command-line option of the form
       * <tt>--<em>key</em>=<em>value</em></tt>.
       *
       * @return The command line options for this property set.
       */
      getCommandLineOptions(): StringSeq;

      /**
       * Convert a sequence of command-line options into properties.
       * All options that begin with
       * <tt>--<em>prefix</em>.</tt> are
       * converted into properties. If the prefix is empty, all options
       * that begin with <tt>--</tt> are converted to properties.
       *
       * @param prefix The property prefix, or an empty string to
       * convert all options starting with <tt>--</tt>.
       *
       * @param options The command-line options.
       *
       * @return The command-line options that do not start with the specified
       * prefix, in their original order.
       */
      parseCommandLineOptions(prefix: string, options: StringSeq): StringSeq;

      /**
       * Convert a sequence of command-line options into properties.
       * All options that begin with one of the following prefixes
       * are converted into properties: <tt>--Ice</tt>, <tt>--IceBox</tt>, <tt>--IceGrid</tt>,
       * <tt>--IcePatch2</tt>, <tt>--IceSSL</tt>, <tt>--IceStorm</tt>, <tt>--Freeze</tt>, and <tt>--Glacier2</tt>.
       *
       * @param options The command-line options.
       *
       * @return The command-line options that do not start with one of
       * the listed prefixes, in their original order.
       */
      parseIceCommandLineOptions(options: StringSeq): StringSeq;

      /**
       * Load properties from a file.
       *
       * @param file The property file.
       */
      load(file: string): void;

      /**
       * Create a copy of this property set.
       *
       * @return A copy of this property set.
       */
      clone(): Properties;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 37`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A simple collection of properties, represented as a dictionary of
     * key/value pairs. Both key and value are strings.
     *
     * @see Properties#getPropertiesForPrefix
     */
    type PropertyDict = Map<string, string>;

    /**
     * The PropertiesAdmin interface provides remote access to the properties
     * of a communicator.
     */
    abstract class PropertiesAdmin extends Ice.Object {
      /**
       * Get a property by key. If the property is not set, an empty
       * string is returned.
       *
       * @param key The property key.
       *
       * @return The property value.
       */
      abstract getProperty(
        key: string,
        current: Ice.Current
      ): Ice.OperationResult<string>;

      /**
       * Get all properties whose keys begin with <em>prefix</em>. If
       * <em>prefix</em> is an empty string then all properties are returned.
       *
       * @param prefix The prefix to search for (empty string if none).
       * @return The matching property set.
       */
      abstract getPropertiesForPrefix(
        prefix: string,
        current: Ice.Current
      ): Ice.OperationResult<PropertyDict>;

      /**
       * Update the communicator's properties with the given property set.
       *
       * @param newProperties Properties to be added, changed, or removed.
       * If an entry in <em>newProperties</em> matches the name of an existing property,
       * that property's value is replaced with the new value. If the new value
       * is an empty string, the property is removed. Any existing properties
       * that are not modified or removed by the entries in newProperties are
       * retained with their original values.
       */
      abstract setProperties(
        newProperties: PropertyDict,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * The PropertiesAdmin interface provides remote access to the properties
     * of a communicator.
     */
    class PropertiesAdminPrx extends Ice.ObjectPrx {
      /**
       * Get a property by key. If the property is not set, an empty
       * string is returned.
       *
       * @param key The property key.
       *
       * @return The property value.
       */
      getProperty(key: string, ctx?: Ice.Context): Ice.AsyncResult<string>;

      /**
       * Get all properties whose keys begin with <em>prefix</em>. If
       * <em>prefix</em> is an empty string then all properties are returned.
       *
       * @param prefix The prefix to search for (empty string if none).
       * @return The matching property set.
       */
      getPropertiesForPrefix(
        prefix: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<PropertyDict>;

      /**
       * Update the communicator's properties with the given property set.
       *
       * @param newProperties Properties to be added, changed, or removed.
       * If an entry in <em>newProperties</em> matches the name of an existing property,
       * that property's value is replaced with the new value. If the new value
       * is an empty string, the property is removed. Any existing properties
       * that are not modified or removed by the entries in newProperties are
       * retained with their original values.
       */
      setProperties(
        newProperties: PropertyDict,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 38`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 39`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    type LogMessageTypeName =
      | \\"PrintMessage\\"
      | \\"TraceMessage\\"
      | \\"WarningMessage\\"
      | \\"ErrorMessage\\";

    /**
     * An enumeration representing the different types of log messages.
     */
    class LogMessageType<
      Name extends LogMessageTypeName = LogMessageTypeName
    > extends Ice.EnumBase<Name> {
      /**
       * The {@link Logger} received a print message.
       */
      static PrintMessage: LogMessageType<\\"PrintMessage\\">;

      /**
       * The {@link Logger} received a trace message.
       */
      static TraceMessage: LogMessageType<\\"TraceMessage\\">;

      /**
       * The {@link Logger} received a warning message.
       */
      static WarningMessage: LogMessageType<\\"WarningMessage\\">;

      /**
       * The {@link Logger} received an error message.
       */
      static ErrorMessage: LogMessageType<\\"ErrorMessage\\">;
    }

    /**
     * A sequence of {@link LogMessageType}
     */
    type LogMessageTypeSeq = Array<LogMessageType>;

    /**
     * A complete log message.
     */
    class LogMessage implements Ice.Struct {
      constructor(
        type?: LogMessageType,
        timestamp?: Ice.Long,
        traceCategory?: string,
        message?: string
      );

      /**
       * The type of message sent to the {@link Logger}.
       */
      type: LogMessageType;

      /**
       * The date and time when the {@link Logger} received this message, expressed
       * as the number of microseconds since the Unix Epoch (00:00:00 UTC on 1 January 1970)
       */
      timestamp: Ice.Long;

      /**
       * For a message of type trace, the trace category of this log message;
       * otherwise, the empty string.
       */
      traceCategory: string;

      /**
       * The log message itself.
       */
      message: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of {@link LogMessage}.
     */
    type LogMessageSeq = Array<LogMessage>;

    /**
     * The Ice remote logger interface. An application can implement a
     * RemoteLogger to receive the log messages sent to the local {@link Logger}
     * of another Ice application.
     */
    abstract class RemoteLogger extends Ice.Object {
      /**
       * init is called by {@link LoggerAdmin#attachRemoteLogger} when a
       * RemoteLogger proxy is attached.
       *
       * @param prefix The prefix of the associated local {@link Logger}
       *
       * @param logMessages Old log messages generated before \\"now\\".
       *
       * @see LoggerAdmin#attachRemoteLogger
       */
      abstract init(
        prefix: string,
        logMessages: LogMessageSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Log a {@link LogMessage}. Note that log may be called by {@link LoggerAdmin}
       * before {@link RemoteLogger#init}.
       *
       * @param message The message to log.
       *
       * @see Logger
       */
      abstract log(
        message: LogMessage,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * The Ice remote logger interface. An application can implement a
     * RemoteLogger to receive the log messages sent to the local {@link Logger}
     * of another Ice application.
     */
    class RemoteLoggerPrx extends Ice.ObjectPrx {
      /**
       * init is called by {@link LoggerAdmin#attachRemoteLogger} when a
       * RemoteLogger proxy is attached.
       *
       * @param prefix The prefix of the associated local {@link Logger}
       *
       * @param logMessages Old log messages generated before \\"now\\".
       *
       * @see LoggerAdmin#attachRemoteLogger
       */
      init(
        prefix: string,
        logMessages: LogMessageSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Log a {@link LogMessage}. Note that log may be called by {@link LoggerAdmin}
       * before {@link RemoteLogger#init}.
       *
       * @param message The message to log.
       *
       * @see Logger
       */
      log(message: LogMessage, ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * An exception thrown by {@link LoggerAdmin#attachRemoteLogger} to report
     * that the provided {@link RemoteLogger} was previously attached to this
     * {@link LoggerAdmin}.
     */
    class RemoteLoggerAlreadyAttachedException extends Ice.UserException {}

    /**
     * The interface of the admin object that allows an Ice application the attach its
     * {@link RemoteLogger} to the {@link Logger} of this admin object's Ice communicator.
     */
    abstract class LoggerAdmin extends Ice.Object {
      /**
       * attachRemoteLogger is called to attach a {@link RemoteLogger} object to
       * the local {@link Logger}.
       * attachRemoteLogger calls init on the provided {@link RemoteLogger} proxy.
       *
       * @param prx A proxy to the remote logger.
       *
       * @param messageTypes The list of message types that the remote logger wishes to receive.
       * An empty list means no filtering (send all message types).
       *
       * @param traceCategories The categories of traces that the remote logger wishes to receive.
       * This parameter is ignored if messageTypes is not empty and does not include trace.
       * An empty list means no filtering (send all trace categories).
       *
       * @param messageMax The maximum number of log messages (of all types) to be provided
       * to {@link RemoteLogger#init}. A negative value requests all messages available.
       *
       * @throws RemoteLoggerAlreadyAttachedException Raised if this remote logger is already
       * attached to this admin object.
       */
      abstract attachRemoteLogger(
        prx: RemoteLoggerPrx | null,
        messageTypes: LogMessageTypeSeq,
        traceCategories: StringSeq,
        messageMax: number,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * detachRemoteLogger is called to detach a {@link RemoteLogger} object from
       * the local {@link Logger}.
       *
       * @param prx A proxy to the remote logger.
       *
       * @return True if the provided remote logger proxy was detached, and false otherwise.
       */
      abstract detachRemoteLogger(
        prx: RemoteLoggerPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<boolean>;

      /**
       * getLog retrieves log messages recently logged.
       *
       * @param messageTypes The list of message types that the caller wishes to receive.
       * An empty list means no filtering (send all message types).
       *
       * @param traceCategories The categories of traces that caller wish to receive.
       * This parameter is ignored if messageTypes is not empty and does not include trace.
       * An empty list means no filtering (send all trace categories).
       *
       * @param messageMax The maximum number of log messages (of all types) to be returned.
       * A negative value requests all messages available.
       *
       * @param prefix The prefix of the associated local {@link Logger}.
       *
       * @return The Log messages.
       */
      abstract getLog(
        messageTypes: LogMessageTypeSeq,
        traceCategories: StringSeq,
        messageMax: number,
        current: Ice.Current
      ): Ice.OperationResult<[LogMessageSeq, string]>;
    }

    /**
     * The interface of the admin object that allows an Ice application the attach its
     * {@link RemoteLogger} to the {@link Logger} of this admin object's Ice communicator.
     */
    class LoggerAdminPrx extends Ice.ObjectPrx {
      /**
       * attachRemoteLogger is called to attach a {@link RemoteLogger} object to
       * the local {@link Logger}.
       * attachRemoteLogger calls init on the provided {@link RemoteLogger} proxy.
       *
       * @param prx A proxy to the remote logger.
       *
       * @param messageTypes The list of message types that the remote logger wishes to receive.
       * An empty list means no filtering (send all message types).
       *
       * @param traceCategories The categories of traces that the remote logger wishes to receive.
       * This parameter is ignored if messageTypes is not empty and does not include trace.
       * An empty list means no filtering (send all trace categories).
       *
       * @param messageMax The maximum number of log messages (of all types) to be provided
       * to {@link RemoteLogger#init}. A negative value requests all messages available.
       *
       * @throws RemoteLoggerAlreadyAttachedException Raised if this remote logger is already
       * attached to this admin object.
       */
      attachRemoteLogger(
        prx: RemoteLoggerPrx | null,
        messageTypes: LogMessageTypeSeq,
        traceCategories: StringSeq,
        messageMax: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * detachRemoteLogger is called to detach a {@link RemoteLogger} object from
       * the local {@link Logger}.
       *
       * @param prx A proxy to the remote logger.
       *
       * @return True if the provided remote logger proxy was detached, and false otherwise.
       */
      detachRemoteLogger(
        prx: RemoteLoggerPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<boolean>;

      /**
       * getLog retrieves log messages recently logged.
       *
       * @param messageTypes The list of message types that the caller wishes to receive.
       * An empty list means no filtering (send all message types).
       *
       * @param traceCategories The categories of traces that caller wish to receive.
       * This parameter is ignored if messageTypes is not empty and does not include trace.
       * An empty list means no filtering (send all trace categories).
       *
       * @param messageMax The maximum number of log messages (of all types) to be returned.
       * A negative value requests all messages available.
       *
       * @param prefix The prefix of the associated local {@link Logger}.
       *
       * @return The Log messages.
       */
      getLog(
        messageTypes: LogMessageTypeSeq,
        traceCategories: StringSeq,
        messageMax: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<[LogMessageSeq, string]>;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 40`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * The Ice router interface. Routers can be set either globally with
     * {@link Communicator#setDefaultRouter}, or with <tt>ice_router</tt> on specific
     * proxies.
     */
    abstract class Router extends Ice.Object {
      /**
       * Get the router's client proxy, i.e., the proxy to use for
       * forwarding requests from the client to the router.
       *
       * If a null proxy is returned, the client will forward requests
       * to the router's endpoints.
       *
       * @param hasRoutingTable Indicates whether or not the router supports a routing
       * table. If it is supported, the Ice runtime will call addProxies to populate the
       * routing table. This out parameter is only supported starting with Ice 3.7.
       * The Ice runtime assumes the router has a routing table if the optional is not
       * set.
       *
       * @return The router's client proxy.
       */
      abstract getClientProxy(
        current: Ice.Current
      ): Ice.OperationResult<[Ice.ObjectPrx | null, boolean | undefined]>;

      /**
       * Get the router's server proxy, i.e., the proxy to use for
       * forwarding requests from the server to the router.
       *
       * @return The router's server proxy.
       */
      abstract getServerProxy(
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Add new proxy information to the router's routing table.
       *
       * @param proxies The proxies to add.
       *
       * @return Proxies discarded by the router.
       */
      abstract addProxies(
        proxies: ObjectProxySeq,
        current: Ice.Current
      ): Ice.OperationResult<ObjectProxySeq>;
    }

    /**
     * The Ice router interface. Routers can be set either globally with
     * {@link Communicator#setDefaultRouter}, or with <tt>ice_router</tt> on specific
     * proxies.
     */
    class RouterPrx extends Ice.ObjectPrx {
      /**
       * Get the router's client proxy, i.e., the proxy to use for
       * forwarding requests from the client to the router.
       *
       * If a null proxy is returned, the client will forward requests
       * to the router's endpoints.
       *
       * @param hasRoutingTable Indicates whether or not the router supports a routing
       * table. If it is supported, the Ice runtime will call addProxies to populate the
       * routing table. This out parameter is only supported starting with Ice 3.7.
       * The Ice runtime assumes the router has a routing table if the optional is not
       * set.
       *
       * @return The router's client proxy.
       */
      getClientProxy(
        ctx?: Ice.Context
      ): Ice.AsyncResult<[Ice.ObjectPrx | null, boolean | undefined]>;

      /**
       * Get the router's server proxy, i.e., the proxy to use for
       * forwarding requests from the server to the router.
       *
       * @return The router's server proxy.
       */
      getServerProxy(ctx?: Ice.Context): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Add new proxy information to the router's routing table.
       *
       * @param proxies The proxies to add.
       *
       * @return Proxies discarded by the router.
       */
      addProxies(
        proxies: ObjectProxySeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<ObjectProxySeq>;
    }

    /**
     * This inferface should be implemented by services implementing the
     * Ice::Router interface. It should be advertised through an Ice
     * object with the identity \`Ice/RouterFinder'. This allows clients to
     * retrieve the router proxy with just the endpoint information of the
     * service.
     */
    abstract class RouterFinder extends Ice.Object {
      /**
       * Get the router proxy implemented by the process hosting this
       * finder object. The proxy might point to several replicas.
       *
       * @return The router proxy.
       */
      abstract getRouter(
        current: Ice.Current
      ): Ice.OperationResult<RouterPrx | null>;
    }

    /**
     * This inferface should be implemented by services implementing the
     * Ice::Router interface. It should be advertised through an Ice
     * object with the identity \`Ice/RouterFinder'. This allows clients to
     * retrieve the router proxy with just the endpoint information of the
     * service.
     */
    class RouterFinderPrx extends Ice.ObjectPrx {
      /**
       * Get the router proxy implemented by the process hosting this
       * finder object. The proxy might point to several replicas.
       *
       * @return The router proxy.
       */
      getRouter(ctx?: Ice.Context): Ice.AsyncResult<RouterPrx | null>;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 41`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 42`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/ObjectAdapterF\\";
import \\"../Ice/Current\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A servant locator is called by an object adapter to
     * locate a servant that is not found in its active servant map.
     *
     * @see ObjectAdapter
     * @see ObjectAdapter#addServantLocator
     * @see ObjectAdapter#findServantLocator
     */
    interface ServantLocator {
      /**
       * Called before a request is dispatched if a
       * servant cannot be found in the object adapter's active servant
       * map. Note that the object adapter does not automatically insert
       * the returned servant into its active servant map. This must be
       * done by the servant locator implementation, if this is desired.
       *
       * <tt>locate</tt> can throw any user exception. If it does, that exception
       * is marshaled back to the client. If the Slice definition for the
       * corresponding operation includes that user exception, the client
       * receives that user exception; otherwise, the client receives
       * {@link UnknownUserException}.
       *
       * If <tt>locate</tt> throws any exception, the Ice run time does <em>not</em>
       * call <tt>finished</tt>.
       *
       * <p class=\\"Note\\">If you call <tt>locate</tt> from your own code, you
       * must also call <tt>finished</tt> when you have finished using the
       * servant, provided that <tt>locate</tt> returned a non-null servant;
       * otherwise, you will get undefined behavior if you use
       * servant locators such as the Freeze Evictor.
       *
       * @param curr Information about the current operation for which
       * a servant is required.
       *
       * @param cookie A \\"cookie\\" that will be passed to <tt>finished</tt>.
       *
       * @return The located servant, or null if no suitable servant has
       * been found.
       *
       * @throws UserException The implementation can raise a UserException
       * and the run time will marshal it as the result of the invocation.
       *
       * @see ObjectAdapter
       * @see Current
       * @see #finished
       */
      locate(curr: Current): [Ice.Object | null, object];

      /**
       * Called by the object adapter after a request has been
       * made. This operation is only called if <tt>locate</tt> was called
       * prior to the request and returned a non-null servant. This
       * operation can be used for cleanup purposes after a request.
       *
       * <tt>finished</tt> can throw any user exception. If it does, that exception
       * is marshaled back to the client. If the Slice definition for the
       * corresponding operation includes that user exception, the client
       * receives that user exception; otherwise, the client receives
       * {@link UnknownUserException}.
       *
       * If both the operation and <tt>finished</tt> throw an exception, the
       * exception thrown by <tt>finished</tt> is marshaled back to the client.
       *
       * @param curr Information about the current operation call for
       * which a servant was located by <tt>locate</tt>.
       *
       * @param servant The servant that was returned by <tt>locate</tt>.
       *
       * @param cookie The cookie that was returned by <tt>locate</tt>.
       *
       * @throws UserException The implementation can raise a UserException
       * and the run time will marshal it as the result of the invocation.
       *
       * @see ObjectAdapter
       * @see Current
       * @see #locate
       */
      finished(curr: Current, servant: Ice.Object | null, cookie: object): void;

      /**
       * Called when the object adapter in which this servant locator is
       * installed is destroyed.
       *
       * @param category Indicates for which category the servant locator
       * is being deactivated.
       *
       * @see ObjectAdapter#destroy
       * @see Communicator#shutdown
       * @see Communicator#destroy
       */
      deactivate(category: string): void;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 43`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 44`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A mapping from type IDs to Slice checksums. The dictionary
     * allows verification at run time that client and server
     * use matching Slice definitions.
     */
    type SliceChecksumDict = Map<string, string>;
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 45`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A factory for values. Value factories are used in several
     * places, such as when Ice receives a class instance and
     * when Freeze restores a persistent value. Value factories
     * must be implemented by the application writer and registered
     * with the communicator.
     */
    interface ValueFactory {
      /**
       * Create a new value for a given value type. The type is the
       * absolute Slice type id, i.e., the id relative to the
       * unnamed top-level Slice module. For example, the absolute
       * Slice type id for an interface <tt>Bar</tt> in the module
       * <tt>Foo</tt> is <tt>::Foo::Bar</tt>.
       *
       * <p class=\\"Note\\">The leading \\"<tt>::</tt>\\" is required.
       *
       * @param type The value type.
       *
       * @return The value created for the given type, or nil if the
       * factory is unable to create the value.
       */
      create(type: string): Ice.Value | null;
    }

    /**
     * A value factory manager maintains a collection of value factories.
     * An application can supply a custom implementation during communicator
     * initialization, otherwise Ice provides a default implementation.
     *
     * @see ValueFactory
     */
    interface ValueFactoryManager {
      /**
       * <p>Add a value factory. Attempting to add a
       * factory with an id for which a factory is already registered
       * throws {@link AlreadyRegisteredException}.</p>
       *
       * <p>When unmarshaling an Ice value, the Ice run time reads the
       * most-derived type id off the wire and attempts to create an
       * instance of the type using a factory. If no instance is created,
       * either because no factory was found, or because all factories
       * returned nil, the behavior of the Ice run time depends on the
       * format with which the value was marshaled:</p>
       *
       * <p>If the value uses the \\"sliced\\" format, Ice ascends the class
       * hierarchy until it finds a type that is recognized by a factory,
       * or it reaches the least-derived type. If no factory is found that
       * can create an instance, the run time throws
       * {@link NoValueFactoryException}.</p>
       *
       * <p>If the value uses the \\"compact\\" format, Ice immediately raises
       * {@link NoValueFactoryException}.</p>
       *
       * <p>The following order is used to locate a factory for a type:</p>
       *
       * <ol>
       *
       * <li>The Ice run-time looks for a factory registered
       * specifically for the type.</li>
       *
       * <li>If no instance has been created, the Ice run-time looks
       * for the default factory, which is registered with an empty type id.
       * </li>
       *
       * <li>If no instance has been created by any of the preceding
       * steps, the Ice run-time looks for a factory that may have been
       * statically generated by the language mapping for non-abstract classes.
       * </li>
       *
       * </ol>
       *
       * @param factory The factory to add.
       *
       * @param id The type id for which the factory can create instances, or
       * an empty string for the default factory.
       */
      add(factory: ValueFactory, id: string): void;

      /**
       * Find an value factory registered with this communicator.
       *
       * @param id The type id for which the factory can create instances,
       * or an empty string for the default factory.
       *
       * @return The value factory, or null if no value factory was
       * found for the given id.
       */
      find(id: string): ValueFactory;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 46`] = `
"import { Ice } from \\"ice\\";

declare module \\"./Ice.ns\\" {
  namespace Ice {
    /**
     * A version structure for the protocol version.
     */
    class ProtocolVersion implements Ice.Struct {
      constructor(major?: number, minor?: number);

      major: number;
      minor: number;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A version structure for the encoding version.
     */
    class EncodingVersion implements Ice.Struct {
      constructor(major?: number, minor?: number);

      major: number;
      minor: number;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }
  }
}
export { Ice } from \\"./Ice.ns\\";
"
`;

exports[`generate typings built-in slices 47`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";
import \\"../Ice/CommunicatorF\\";
import \\"../Ice/PropertiesF\\";
import \\"../Ice/SliceChecksumDict\\";

declare module \\"./IceBox.ns\\" {
  /**
   * IceBox is an application server specifically for Ice
   * applications. IceBox can easily run and administer Ice services
   * that are dynamically loaded as a DLL, shared library, or Java
   * class.
   */
  namespace IceBox {
    /**
     * This exception is a general failure notification. It is thrown
     * for errors such as a service encountering an error during
     * initialization, or the service manager being unable
     * to load a service executable.
     */
    class FailureException extends Ice.LocalException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception is thrown if an attempt is made to start an
     * already-started service.
     */
    class AlreadyStartedException extends Ice.UserException {}

    /**
     * This exception is thrown if an attempt is made to stop an
     * already-stopped service.
     */
    class AlreadyStoppedException extends Ice.UserException {}

    /**
     * This exception is thrown if a service name does not refer
     * to an existing service.
     */
    class NoSuchServiceException extends Ice.UserException {}

    /**
     * An application service managed by a {@link ServiceManager}.
     */
    interface Service {
      /**
       * Start the service. The given communicator is created by the
       * {@link ServiceManager} for use by the service. This communicator may
       * also be used by other services, depending on the service
       * configuration.
       *
       * <p class=\\"Note\\">The {@link ServiceManager} owns this communicator, and is
       * responsible for destroying it.
       *
       * @param name The service's name, as determined by the
       * configuration.
       *
       * @param communicator A communicator for use by the service.
       *
       * @param args The service arguments that were not converted into
       * properties.
       *
       * @throws FailureException Raised if {@link #start} failed.
       */
      start(
        name: string,
        communicator: Ice.Communicator,
        args: Ice.StringSeq
      ): void;

      /**
       * Stop the service.
       */
      stop(): void;
    }

    /**
     * An Observer interface implemented by admin clients
     * interested in the status of services
     *
     * @see ServiceManager
     */
    abstract class ServiceObserver extends Ice.Object {
      abstract servicesStarted(
        services: Ice.StringSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;
      abstract servicesStopped(
        services: Ice.StringSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * An Observer interface implemented by admin clients
     * interested in the status of services
     *
     * @see ServiceManager
     */
    class ServiceObserverPrx extends Ice.ObjectPrx {
      servicesStarted(
        services: Ice.StringSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      servicesStopped(
        services: Ice.StringSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }

    /**
     * Administers a set of {@link Service} instances.
     *
     * @see Service
     */
    abstract class ServiceManager extends Ice.Object {
      /**
       * Returns the checksums for the IceBox Slice definitions.
       *
       * @return A dictionary mapping Slice type ids to their checksums.
       */
      abstract getSliceChecksums(
        current: Ice.Current
      ): Ice.OperationResult<Ice.SliceChecksumDict>;

      /**
       * Start an individual service.
       *
       * @param service The service name.
       *
       * @throws AlreadyStartedException If the service is already running.
       * @throws NoSuchServiceException If no service could be found with the given name.
       */
      abstract startService(
        service: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Stop an individual service.
       *
       * @param service The service name.
       *
       * @throws AlreadyStoppedException If the service is already stopped.
       * @throws NoSuchServiceException If no service could be found with the given name.
       */
      abstract stopService(
        service: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Registers a new observer with the ServiceManager.
       *
       * @param observer The new observer
       */
      abstract addObserver(
        observer: ServiceObserverPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Shut down all services. This causes {@link Service#stop} to be
       * invoked on all configured services.
       */
      abstract shutdown(current: Ice.Current): Ice.OperationResult<void>;
    }

    /**
     * Administers a set of {@link Service} instances.
     *
     * @see Service
     */
    class ServiceManagerPrx extends Ice.ObjectPrx {
      /**
       * Returns the checksums for the IceBox Slice definitions.
       *
       * @return A dictionary mapping Slice type ids to their checksums.
       */
      getSliceChecksums(
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.SliceChecksumDict>;

      /**
       * Start an individual service.
       *
       * @param service The service name.
       *
       * @throws AlreadyStartedException If the service is already running.
       * @throws NoSuchServiceException If no service could be found with the given name.
       */
      startService(service: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Stop an individual service.
       *
       * @param service The service name.
       *
       * @throws AlreadyStoppedException If the service is already stopped.
       * @throws NoSuchServiceException If no service could be found with the given name.
       */
      stopService(service: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Registers a new observer with the ServiceManager.
       *
       * @param observer The new observer
       */
      addObserver(
        observer: ServiceObserverPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Shut down all services. This causes {@link Service#stop} to be
       * invoked on all configured services.
       */
      shutdown(ctx?: Ice.Context): Ice.AsyncResult<void>;
    }
  }
}
export { IceBox } from \\"./IceBox.ns\\";
"
`;

exports[`generate typings built-in slices 48`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Connection\\";

declare module \\"./IceBT.ns\\" {
  namespace IceBT {
    /**
     * Provides access to the details of a Bluetooth connection.
     */
    class ConnectionInfo extends Ice.ConnectionInfo {
      constructor(
        underlying?: Ice.ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string,
        localAddress?: string,
        localChannel?: number,
        remoteAddress?: string,
        remoteChannel?: number,
        uuid?: string,
        rcvSize?: number,
        sndSize?: number
      );

      localAddress: string;
      localChannel: number;
      remoteAddress: string;
      remoteChannel: number;
      uuid: string;
      rcvSize: number;
      sndSize: number;
    }
  }
}
export { IceBT } from \\"./IceBT.ns\\";
"
`;

exports[`generate typings built-in slices 49`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Endpoint\\";

declare module \\"./IceBT.ns\\" {
  /**
   * IceBT provides a Bluetooth transport for Ice.
   */
  namespace IceBT {
    /**
     * Provides access to Bluetooth endpoint information.
     */
    class EndpointInfo extends Ice.EndpointInfo {
      constructor(
        underlying?: Ice.EndpointInfo | null,
        timeout?: number,
        compress?: boolean,
        addr?: string,
        uuid?: string
      );

      /**
       * The address configured with the endpoint.
       */
      addr: string;

      /**
       * The UUID configured with the endpoint.
       */
      uuid: string;
    }
  }
}
export { IceBT } from \\"./IceBT.ns\\";
"
`;

exports[`generate typings built-in slices 50`] = `
"import { Ice } from \\"ice\\";

declare module \\"./IceBT.ns\\" {
  /**
   * IceBT provides a Bluetooth transport for Ice.
   */
  namespace IceBT {
    /**
     * Indicates a failure in the Bluetooth plug-in.
     */
    class BluetoothException extends Ice.LocalException {
      constructor(reason?: string);

      reason: string;
    }
  }
}
export { IceBT } from \\"./IceBT.ns\\";
"
`;

exports[`generate typings built-in slices 51`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Identity\\";

declare module \\"./IceDiscovery.ns\\" {
  namespace IceDiscovery {
    abstract class LookupReply extends Ice.Object {
      abstract foundObjectById(
        id: Ice.Identity,
        prx: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;
      abstract foundAdapterById(
        id: string,
        prx: Ice.ObjectPrx | null,
        isReplicaGroup: boolean,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    class LookupReplyPrx extends Ice.ObjectPrx {
      foundObjectById(
        id: Ice.Identity,
        prx: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      foundAdapterById(
        id: string,
        prx: Ice.ObjectPrx | null,
        isReplicaGroup: boolean,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }

    abstract class Lookup extends Ice.Object {
      abstract findObjectById(
        domainId: string,
        id: Ice.Identity,
        reply: LookupReplyPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;
      abstract findAdapterById(
        domainId: string,
        id: string,
        reply: LookupReplyPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    class LookupPrx extends Ice.ObjectPrx {
      findObjectById(
        domainId: string,
        id: Ice.Identity,
        reply: LookupReplyPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      findAdapterById(
        domainId: string,
        id: string,
        reply: LookupReplyPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }
  }
}
export { IceDiscovery } from \\"./IceDiscovery.ns\\";
"
`;

exports[`generate typings built-in slices 52`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Identity\\";
import \\"../Ice/BuiltinSequences\\";
import \\"../Ice/Properties\\";
import \\"../Ice/SliceChecksumDict\\";
import { Glacier2 } from \\"../Glacier2/Session\\";
import { IceGrid } from \\"../IceGrid/Exception\\";
import \\"../IceGrid/Descriptor\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    type ServerStateName =
      | \\"Inactive\\"
      | \\"Activating\\"
      | \\"ActivationTimedOut\\"
      | \\"Active\\"
      | \\"Deactivating\\"
      | \\"Destroying\\"
      | \\"Destroyed\\";

    /**
     * An enumeration representing the state of the server.
     */
    class ServerState<
      Name extends ServerStateName = ServerStateName
    > extends Ice.EnumBase<Name> {
      /**
       * The server is not running.
       */
      static Inactive: ServerState<\\"Inactive\\">;

      /**
       * The server is being activated and will change to the active
       * state when the registered server object adapters are activated
       * or to the activation timed out state if the activation timeout
       * expires.
       */
      static Activating: ServerState<\\"Activating\\">;

      /**
       * The activation timed out state indicates that the server
       * activation timed out.
       */
      static ActivationTimedOut: ServerState<\\"ActivationTimedOut\\">;

      /**
       * The server is running.
       */
      static Active: ServerState<\\"Active\\">;

      /**
       * The server is being deactivated.
       */
      static Deactivating: ServerState<\\"Deactivating\\">;

      /**
       * The server is being destroyed.
       */
      static Destroying: ServerState<\\"Destroying\\">;

      /**
       * The server is destroyed.
       */
      static Destroyed: ServerState<\\"Destroyed\\">;
    }

    /**
     * A dictionary of proxies.
     */
    type StringObjectProxyDict = Map<string, Ice.ObjectPrx | null>;

    /**
     * Information about an Ice object.
     */
    class ObjectInfo implements Ice.Struct {
      constructor(proxy?: Ice.ObjectPrx | null, type?: string);

      /**
       * The proxy of the object.
       */
      proxy: Ice.ObjectPrx | null;

      /**
       * The type of the object.
       */
      type: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of object information structures.
     */
    type ObjectInfoSeq = Array<ObjectInfo>;

    /**
     * Information about an adapter registered with the IceGrid registry.
     */
    class AdapterInfo implements Ice.Struct {
      constructor(
        id?: string,
        proxy?: Ice.ObjectPrx | null,
        replicaGroupId?: string
      );

      /**
       * The id of the adapter.
       */
      id: string;

      /**
       * A dummy direct proxy that contains the adapter endpoints.
       */
      proxy: Ice.ObjectPrx | null;

      /**
       * The replica group id of the object adapter, or empty if the
       * adapter doesn't belong to a replica group.
       */
      replicaGroupId: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of adapter information structures.
     */
    type AdapterInfoSeq = Array<AdapterInfo>;

    /**
     * Information about a server managed by an IceGrid node.
     */
    class ServerInfo implements Ice.Struct {
      constructor(
        application?: string,
        uuid?: string,
        revision?: number,
        node?: string,
        descriptor?: ServerDescriptor | null,
        sessionId?: string
      );

      /**
       * The server application.
       */
      application: string;

      /**
       * The application uuid.
       */
      uuid: string;

      /**
       * The application revision.
       */
      revision: number;

      /**
       * The server node.
       */
      node: string;

      /**
       * The server descriptor.
       */
      descriptor: ServerDescriptor | null;

      /**
       * The id of the session which allocated the server.
       */
      sessionId: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * Information about an IceGrid node.
     */
    class NodeInfo implements Ice.Struct {
      constructor(
        name?: string,
        os?: string,
        hostname?: string,
        release?: string,
        version?: string,
        machine?: string,
        nProcessors?: number,
        dataDir?: string
      );

      /**
       * The name of the node.
       */
      name: string;

      /**
       * The operating system name.
       */
      os: string;

      /**
       * The network name of the host running this node (as defined in
       * uname()).
       */
      hostname: string;

      /**
       * The operation system release level (as defined in uname()).
       */
      release: string;

      /**
       * The operation system version (as defined in uname()).
       */
      version: string;

      /**
       * The machine hardware type (as defined in uname()).
       */
      machine: string;

      /**
       * The number of processor threads on the node.
       * For example, nProcessors is 8 on a computer with a single quad-core
       * processor and two HT threads per core.
       */
      nProcessors: number;

      /**
       * The path to the node data directory.
       */
      dataDir: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * Information about an IceGrid registry replica.
     */
    class RegistryInfo implements Ice.Struct {
      constructor(name?: string, hostname?: string);

      /**
       * The name of the registry.
       */
      name: string;

      /**
       * The network name of the host running this registry (as defined in
       * uname()).
       */
      hostname: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of {@link RegistryInfo} structures.
     */
    type RegistryInfoSeq = Array<RegistryInfo>;

    /**
     * Information about the load of a node.
     */
    class LoadInfo implements Ice.Struct {
      constructor(avg1?: number, avg5?: number, avg15?: number);

      avg1: number;
      avg5: number;
      avg15: number;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * Information about an IceGrid application.
     */
    class ApplicationInfo implements Ice.Struct {
      constructor(
        uuid?: string,
        createTime?: Ice.Long,
        createUser?: string,
        updateTime?: Ice.Long,
        updateUser?: string,
        revision?: number,
        descriptor?: ApplicationDescriptor
      );

      uuid: string;
      createTime: Ice.Long;
      createUser: string;
      updateTime: Ice.Long;
      updateUser: string;
      revision: number;
      descriptor: ApplicationDescriptor;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of {@link ApplicationInfo} structures.
     */
    type ApplicationInfoSeq = Array<ApplicationInfo>;

    /**
     * Information about updates to an IceGrid application.
     */
    class ApplicationUpdateInfo implements Ice.Struct {
      constructor(
        updateTime?: Ice.Long,
        updateUser?: string,
        revision?: number,
        descriptor?: ApplicationUpdateDescriptor
      );

      updateTime: Ice.Long;
      updateUser: string;
      revision: number;
      descriptor: ApplicationUpdateDescriptor;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * The IceGrid administrative interface.
     * <p class=\\"Warning\\">Allowing access to this interface
     * is a security risk! Please see the IceGrid documentation
     * for further information.
     */
    abstract class Admin extends Ice.Object {
      /**
       * Add an application to IceGrid.
       *
       * @param descriptor The application descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       */
      abstract addApplication(
        descriptor: ApplicationDescriptor,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Synchronize a deployed application with the given application
       * descriptor. This operation will replace the current descriptor
       * with this new descriptor.
       *
       * @param descriptor The application descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      abstract syncApplication(
        descriptor: ApplicationDescriptor,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Update a deployed application with the given update application
       * descriptor.
       *
       * @param descriptor The update descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      abstract updateApplication(
        descriptor: ApplicationUpdateDescriptor,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Synchronize a deployed application with the given application
       * descriptor. This operation will replace the current descriptor
       * with this new descriptor only if no server restarts are
       * necessary for the update of the application. If some servers
       * need to be restarted, the synchronization is rejected with a
       * DeploymentException.
       *
       * @param descriptor The application descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      abstract syncApplicationWithoutRestart(
        descriptor: ApplicationDescriptor,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Update a deployed application with the given update application
       * descriptor only if no server restarts are necessary for the
       * update of the application. If some servers need to be
       * restarted, the synchronization is rejected with a
       * DeploymentException.
       *
       * @param descriptor The update descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      abstract updateApplicationWithoutRestart(
        descriptor: ApplicationUpdateDescriptor,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Remove an application from IceGrid.
       *
       * @param name The application name.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      abstract removeApplication(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Instantiate a server template from an application on the given
       * node.
       *
       * @param application The application name.
       *
       * @param node The name of the node where the server will be
       * deployed.
       *
       * @param desc The descriptor of the server instance to deploy.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if server instantiation
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      abstract instantiateServer(
        application: string,
        node: string,
        desc: ServerInstanceDescriptor,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Patch the given application data.
       *
       * @param name The application name.
       *
       * @param shutdown If true, the servers depending on the data to
       * patch will be shut down if necessary.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       *
       * @throws PatchException Raised if the patch failed.
       */
      abstract patchApplication(
        name: string,
        shutdown: boolean,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Get an application descriptor.
       *
       * @param name The application name.
       *
       * @return The application descriptor.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      abstract getApplicationInfo(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<ApplicationInfo>;

      /**
       * Get the default application descriptor.
       *
       * @return The default application descriptor.
       *
       * @throws DeploymentException Raised if the default application
       * descriptor can't be accessed or is invalid.
       */
      abstract getDefaultApplicationDescriptor(
        current: Ice.Current
      ): Ice.OperationResult<ApplicationDescriptor>;

      /**
       * Get all the IceGrid applications currently registered.
       *
       * @return The application names.
       */
      abstract getAllApplicationNames(
        current: Ice.Current
      ): Ice.OperationResult<Ice.StringSeq>;

      /**
       * Get the server information for the server with the given id.
       *
       * @param id The server id.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @return The server information.
       */
      abstract getServerInfo(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<ServerInfo>;

      /**
       * Get a server's state.
       *
       * @param id The server id.
       *
       * @return The server state.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract getServerState(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<ServerState>;

      /**
       * Get a server's system process id. The process id is operating
       * system dependent.
       *
       * @param id The server id.
       *
       * @return The server's process id.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract getServerPid(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<number>;

      /**
       * Get the category for server admin objects. You can manufacture a server admin
       * proxy from the admin proxy by changing its identity: use the server ID as name
       * and the returned category as category.
       *
       * @return The category for server admin objects.
       */
      abstract getServerAdminCategory(
        current: Ice.Current
      ): Ice.OperationResult<string>;

      /**
       * Get a proxy to the server's admin object.
       *
       * @param id The server id.
       *
       * @return A proxy to the server's admin object
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract getServerAdmin(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Enable or disable a server. A disabled server can't be started
       * on demand or administratively. The enable state of the server
       * is not persistent: if the node is shut down and restarted, the
       * server will be enabled by default.
       *
       * @param id The server id.
       *
       * @param enabled True to enable the server, false to disable it.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract enableServer(
        id: string,
        enabled: boolean,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Check if the server is enabled or disabled.
       *
       * @param id The server id.
       *
       * @return True if the server is enabled.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract isServerEnabled(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<boolean>;

      /**
       * Start a server and wait for its activation.
       *
       * @param id The server id.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws ServerStartException Raised if the server couldn't be
       * started.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract startServer(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Stop a server.
       *
       * @param id The server id.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws ServerStopException Raised if the server couldn't be
       * stopped.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract stopServer(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Patch a server.
       *
       * @param id The server id.
       *
       * @param shutdown If true, servers depending on the data to patch
       * will be shut down if necessary.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       *
       * @throws PatchException Raised if the patch failed.
       */
      abstract patchServer(
        id: string,
        shutdown: boolean,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Send signal to a server.
       *
       * @param id The server id.
       *
       * @param signal The signal, for example SIGTERM or 15.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       *
       * @throws BadSignalException Raised if the signal is not recognized
       * by the target server.
       */
      abstract sendSignal(
        id: string,
        signal: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Get all the server ids registered with IceGrid.
       *
       * @return The server ids.
       */
      abstract getAllServerIds(
        current: Ice.Current
      ): Ice.OperationResult<Ice.StringSeq>;

      /**
       * Get the adapter information for the replica group or adapter
       * with the given id.
       *
       * @param id The adapter id.
       *
       * @return A sequence of adapter information structures. If the
       * given id refers to an adapter, this sequence will contain only
       * one element. If the given id refers to a replica group, the
       * sequence will contain the adapter information of each member of
       * the replica group.
       *
       * @throws AdapterNotExistException Raised if the adapter or
       * replica group doesn't exist.
       */
      abstract getAdapterInfo(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<AdapterInfoSeq>;

      /**
       * Remove the adapter with the given id.
       *
       * @param id The adapter id.
       * @throws AdapterNotExistException Raised if the adapter doesn't
       * exist.
       *
       * @throws DeploymentException Raised if application deployment failed.
       */
      abstract removeAdapter(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Get all the adapter ids registered with IceGrid.
       *
       * @return The adapter ids.
       */
      abstract getAllAdapterIds(
        current: Ice.Current
      ): Ice.OperationResult<Ice.StringSeq>;

      /**
       * Add an object to the object registry. IceGrid will get the
       * object type by calling <tt>ice_id</tt> on the given proxy. The object
       * must be reachable.
       *
       * @param obj The object to be added to the registry.
       *
       * @throws ObjectExistsException Raised if the object is already
       * registered.
       *
       * @throws DeploymentException Raised if the object can't be
       * added. This might be raised if the invocation on the proxy to
       * get the object type failed.
       */
      abstract addObject(
        obj: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Update an object in the object registry. Only objects added
       * with this interface can be updated with this operation. Objects
       * added with deployment descriptors should be updated with the
       * deployment mechanism.
       *
       * @param obj The object to be updated to the registry.
       *
       * @throws ObjectNotRegisteredException Raised if the object isn't
       * registered with the registry.
       *
       * @throws DeploymentException Raised if the object can't be
       * updated. This might happen if the object was added with a
       * deployment descriptor.
       */
      abstract updateObject(
        obj: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Add an object to the object registry and explicitly specify
       * its type.
       *
       * @param obj The object to be added to the registry.
       *
       * @param type The object type.
       *
       * @throws ObjectExistsException Raised if the object is already
       * registered.
       *
       * @throws DeploymentException Raised if application deployment failed.
       */
      abstract addObjectWithType(
        obj: Ice.ObjectPrx | null,
        type: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Remove an object from the object registry. Only objects added
       * with this interface can be removed with this operation. Objects
       * added with deployment descriptors should be removed with the
       * deployment mechanism.
       *
       * @param id The identity of the object to be removed from the
       * registry.
       *
       * @throws ObjectNotRegisteredException Raised if the object isn't
       * registered with the registry.
       *
       * @throws DeploymentException Raised if the object can't be
       * removed. This might happen if the object was added with a
       * deployment descriptor.
       */
      abstract removeObject(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Get the object info for the object with the given identity.
       *
       * @param id The identity of the object.
       *
       * @return The object info.
       *
       * @throws ObjectNotRegisteredException Raised if the object isn't
       * registered with the registry.
       */
      abstract getObjectInfo(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<ObjectInfo>;

      /**
       * Get the object info of all the registered objects with the
       * given type.
       *
       * @param type The type of the object.
       *
       * @return The object infos.
       */
      abstract getObjectInfosByType(
        type: string,
        current: Ice.Current
      ): Ice.OperationResult<ObjectInfoSeq>;

      /**
       * Get the object info of all the registered objects whose stringified
       * identities match the given expression.
       *
       * @param expr The expression to match against the stringified
       * identities of registered objects. The expression may contain
       * a trailing wildcard (<tt>*</tt>) character.
       *
       * @return All the object infos with a stringified identity
       * matching the given expression.
       */
      abstract getAllObjectInfos(
        expr: string,
        current: Ice.Current
      ): Ice.OperationResult<ObjectInfoSeq>;

      /**
       * Ping an IceGrid node to see if it is active.
       *
       * @param name The node name.
       *
       * @return true if the node ping succeeded, false otherwise.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       */
      abstract pingNode(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<boolean>;

      /**
       * Get the load averages of the node.
       *
       * @param name The node name.
       *
       * @return The node load information.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      abstract getNodeLoad(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<LoadInfo>;

      /**
       * Get the node information for the node with the given name.
       *
       * @param name The node name.
       *
       * @return The node information.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      abstract getNodeInfo(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<NodeInfo>;

      /**
       * Get a proxy to the IceGrid node's admin object.
       *
       * @param name The IceGrid node name
       *
       * @return A proxy to the IceGrid node's admin object
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      abstract getNodeAdmin(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Get the number of physical processor sockets for the machine
       * running the node with the given name.
       *
       * Note that this method will return 1 on operating systems where
       * this can't be automatically determined and where the
       * IceGrid.Node.ProcessorSocketCount property for the node is not
       * set.
       *
       * @param name The node name.
       *
       * @return The number of processor sockets or 1 if the number of
       * sockets can't determined.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      abstract getNodeProcessorSocketCount(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<number>;

      /**
       * Shutdown an IceGrid node.
       *
       * @param name The node name.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      abstract shutdownNode(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Get the hostname of this node.
       *
       * @param name The node name.
       *
       * @return The node hostname.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      abstract getNodeHostname(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<string>;

      /**
       * Get all the IceGrid nodes currently registered.
       *
       * @return The node names.
       */
      abstract getAllNodeNames(
        current: Ice.Current
      ): Ice.OperationResult<Ice.StringSeq>;

      /**
       * Ping an IceGrid registry to see if it is active.
       *
       * @param name The registry name.
       *
       * @return true if the registry ping succeeded, false otherwise.
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       */
      abstract pingRegistry(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<boolean>;

      /**
       * Get the registry information for the registry with the given name.
       *
       * @param name The registry name.
       *
       * @return The registry information.
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry could not be
       * reached.
       */
      abstract getRegistryInfo(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<RegistryInfo>;

      /**
       * Get a proxy to the IceGrid registry's admin object.
       *
       * @param name The registry name
       *
       * @return A proxy to the IceGrid registry's admin object
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       */
      abstract getRegistryAdmin(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Shutdown an IceGrid registry.
       *
       * @param name The registry name.
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry could not be
       * reached.
       */
      abstract shutdownRegistry(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Get all the IceGrid registries currently registered.
       *
       * @return The registry names.
       */
      abstract getAllRegistryNames(
        current: Ice.Current
      ): Ice.OperationResult<Ice.StringSeq>;

      /**
       * Shut down the IceGrid registry.
       */
      abstract shutdown(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Returns the checksums for the IceGrid Slice definitions.
       *
       * @return A dictionary mapping Slice type ids to their checksums.
       */
      abstract getSliceChecksums(
        current: Ice.Current
      ): Ice.OperationResult<Ice.SliceChecksumDict>;
    }

    /**
     * The IceGrid administrative interface.
     * <p class=\\"Warning\\">Allowing access to this interface
     * is a security risk! Please see the IceGrid documentation
     * for further information.
     */
    class AdminPrx extends Ice.ObjectPrx {
      /**
       * Add an application to IceGrid.
       *
       * @param descriptor The application descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       */
      addApplication(
        descriptor: ApplicationDescriptor,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Synchronize a deployed application with the given application
       * descriptor. This operation will replace the current descriptor
       * with this new descriptor.
       *
       * @param descriptor The application descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      syncApplication(
        descriptor: ApplicationDescriptor,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Update a deployed application with the given update application
       * descriptor.
       *
       * @param descriptor The update descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      updateApplication(
        descriptor: ApplicationUpdateDescriptor,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Synchronize a deployed application with the given application
       * descriptor. This operation will replace the current descriptor
       * with this new descriptor only if no server restarts are
       * necessary for the update of the application. If some servers
       * need to be restarted, the synchronization is rejected with a
       * DeploymentException.
       *
       * @param descriptor The application descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      syncApplicationWithoutRestart(
        descriptor: ApplicationDescriptor,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Update a deployed application with the given update application
       * descriptor only if no server restarts are necessary for the
       * update of the application. If some servers need to be
       * restarted, the synchronization is rejected with a
       * DeploymentException.
       *
       * @param descriptor The update descriptor.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      updateApplicationWithoutRestart(
        descriptor: ApplicationUpdateDescriptor,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Remove an application from IceGrid.
       *
       * @param name The application name.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if application deployment failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      removeApplication(name: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Instantiate a server template from an application on the given
       * node.
       *
       * @param application The application name.
       *
       * @param node The name of the node where the server will be
       * deployed.
       *
       * @param desc The descriptor of the server instance to deploy.
       *
       * @throws AccessDeniedException Raised if the session doesn't
       * hold the exclusive lock or if another session is holding the
       * lock.
       *
       * @throws DeploymentException Raised if server instantiation
       * failed.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      instantiateServer(
        application: string,
        node: string,
        desc: ServerInstanceDescriptor,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Patch the given application data.
       *
       * @param name The application name.
       *
       * @param shutdown If true, the servers depending on the data to
       * patch will be shut down if necessary.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       *
       * @throws PatchException Raised if the patch failed.
       */
      patchApplication(
        name: string,
        shutdown: boolean,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Get an application descriptor.
       *
       * @param name The application name.
       *
       * @return The application descriptor.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      getApplicationInfo(
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<ApplicationInfo>;

      /**
       * Get the default application descriptor.
       *
       * @return The default application descriptor.
       *
       * @throws DeploymentException Raised if the default application
       * descriptor can't be accessed or is invalid.
       */
      getDefaultApplicationDescriptor(
        ctx?: Ice.Context
      ): Ice.AsyncResult<ApplicationDescriptor>;

      /**
       * Get all the IceGrid applications currently registered.
       *
       * @return The application names.
       */
      getAllApplicationNames(ctx?: Ice.Context): Ice.AsyncResult<Ice.StringSeq>;

      /**
       * Get the server information for the server with the given id.
       *
       * @param id The server id.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @return The server information.
       */
      getServerInfo(id: string, ctx?: Ice.Context): Ice.AsyncResult<ServerInfo>;

      /**
       * Get a server's state.
       *
       * @param id The server id.
       *
       * @return The server state.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      getServerState(
        id: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<ServerState>;

      /**
       * Get a server's system process id. The process id is operating
       * system dependent.
       *
       * @param id The server id.
       *
       * @return The server's process id.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      getServerPid(id: string, ctx?: Ice.Context): Ice.AsyncResult<number>;

      /**
       * Get the category for server admin objects. You can manufacture a server admin
       * proxy from the admin proxy by changing its identity: use the server ID as name
       * and the returned category as category.
       *
       * @return The category for server admin objects.
       */
      getServerAdminCategory(ctx?: Ice.Context): Ice.AsyncResult<string>;

      /**
       * Get a proxy to the server's admin object.
       *
       * @param id The server id.
       *
       * @return A proxy to the server's admin object
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      getServerAdmin(
        id: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Enable or disable a server. A disabled server can't be started
       * on demand or administratively. The enable state of the server
       * is not persistent: if the node is shut down and restarted, the
       * server will be enabled by default.
       *
       * @param id The server id.
       *
       * @param enabled True to enable the server, false to disable it.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      enableServer(
        id: string,
        enabled: boolean,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Check if the server is enabled or disabled.
       *
       * @param id The server id.
       *
       * @return True if the server is enabled.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      isServerEnabled(id: string, ctx?: Ice.Context): Ice.AsyncResult<boolean>;

      /**
       * Start a server and wait for its activation.
       *
       * @param id The server id.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws ServerStartException Raised if the server couldn't be
       * started.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      startServer(id: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Stop a server.
       *
       * @param id The server id.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws ServerStopException Raised if the server couldn't be
       * stopped.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      stopServer(id: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Patch a server.
       *
       * @param id The server id.
       *
       * @param shutdown If true, servers depending on the data to patch
       * will be shut down if necessary.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       *
       * @throws PatchException Raised if the patch failed.
       */
      patchServer(
        id: string,
        shutdown: boolean,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Send signal to a server.
       *
       * @param id The server id.
       *
       * @param signal The signal, for example SIGTERM or 15.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       *
       * @throws BadSignalException Raised if the signal is not recognized
       * by the target server.
       */
      sendSignal(
        id: string,
        signal: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Get all the server ids registered with IceGrid.
       *
       * @return The server ids.
       */
      getAllServerIds(ctx?: Ice.Context): Ice.AsyncResult<Ice.StringSeq>;

      /**
       * Get the adapter information for the replica group or adapter
       * with the given id.
       *
       * @param id The adapter id.
       *
       * @return A sequence of adapter information structures. If the
       * given id refers to an adapter, this sequence will contain only
       * one element. If the given id refers to a replica group, the
       * sequence will contain the adapter information of each member of
       * the replica group.
       *
       * @throws AdapterNotExistException Raised if the adapter or
       * replica group doesn't exist.
       */
      getAdapterInfo(
        id: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<AdapterInfoSeq>;

      /**
       * Remove the adapter with the given id.
       *
       * @param id The adapter id.
       * @throws AdapterNotExistException Raised if the adapter doesn't
       * exist.
       *
       * @throws DeploymentException Raised if application deployment failed.
       */
      removeAdapter(id: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Get all the adapter ids registered with IceGrid.
       *
       * @return The adapter ids.
       */
      getAllAdapterIds(ctx?: Ice.Context): Ice.AsyncResult<Ice.StringSeq>;

      /**
       * Add an object to the object registry. IceGrid will get the
       * object type by calling <tt>ice_id</tt> on the given proxy. The object
       * must be reachable.
       *
       * @param obj The object to be added to the registry.
       *
       * @throws ObjectExistsException Raised if the object is already
       * registered.
       *
       * @throws DeploymentException Raised if the object can't be
       * added. This might be raised if the invocation on the proxy to
       * get the object type failed.
       */
      addObject(
        obj: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Update an object in the object registry. Only objects added
       * with this interface can be updated with this operation. Objects
       * added with deployment descriptors should be updated with the
       * deployment mechanism.
       *
       * @param obj The object to be updated to the registry.
       *
       * @throws ObjectNotRegisteredException Raised if the object isn't
       * registered with the registry.
       *
       * @throws DeploymentException Raised if the object can't be
       * updated. This might happen if the object was added with a
       * deployment descriptor.
       */
      updateObject(
        obj: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Add an object to the object registry and explicitly specify
       * its type.
       *
       * @param obj The object to be added to the registry.
       *
       * @param type The object type.
       *
       * @throws ObjectExistsException Raised if the object is already
       * registered.
       *
       * @throws DeploymentException Raised if application deployment failed.
       */
      addObjectWithType(
        obj: Ice.ObjectPrx | null,
        type: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Remove an object from the object registry. Only objects added
       * with this interface can be removed with this operation. Objects
       * added with deployment descriptors should be removed with the
       * deployment mechanism.
       *
       * @param id The identity of the object to be removed from the
       * registry.
       *
       * @throws ObjectNotRegisteredException Raised if the object isn't
       * registered with the registry.
       *
       * @throws DeploymentException Raised if the object can't be
       * removed. This might happen if the object was added with a
       * deployment descriptor.
       */
      removeObject(id: Ice.Identity, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Get the object info for the object with the given identity.
       *
       * @param id The identity of the object.
       *
       * @return The object info.
       *
       * @throws ObjectNotRegisteredException Raised if the object isn't
       * registered with the registry.
       */
      getObjectInfo(
        id: Ice.Identity,
        ctx?: Ice.Context
      ): Ice.AsyncResult<ObjectInfo>;

      /**
       * Get the object info of all the registered objects with the
       * given type.
       *
       * @param type The type of the object.
       *
       * @return The object infos.
       */
      getObjectInfosByType(
        type: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<ObjectInfoSeq>;

      /**
       * Get the object info of all the registered objects whose stringified
       * identities match the given expression.
       *
       * @param expr The expression to match against the stringified
       * identities of registered objects. The expression may contain
       * a trailing wildcard (<tt>*</tt>) character.
       *
       * @return All the object infos with a stringified identity
       * matching the given expression.
       */
      getAllObjectInfos(
        expr: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<ObjectInfoSeq>;

      /**
       * Ping an IceGrid node to see if it is active.
       *
       * @param name The node name.
       *
       * @return true if the node ping succeeded, false otherwise.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       */
      pingNode(name: string, ctx?: Ice.Context): Ice.AsyncResult<boolean>;

      /**
       * Get the load averages of the node.
       *
       * @param name The node name.
       *
       * @return The node load information.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      getNodeLoad(name: string, ctx?: Ice.Context): Ice.AsyncResult<LoadInfo>;

      /**
       * Get the node information for the node with the given name.
       *
       * @param name The node name.
       *
       * @return The node information.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      getNodeInfo(name: string, ctx?: Ice.Context): Ice.AsyncResult<NodeInfo>;

      /**
       * Get a proxy to the IceGrid node's admin object.
       *
       * @param name The IceGrid node name
       *
       * @return A proxy to the IceGrid node's admin object
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      getNodeAdmin(
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Get the number of physical processor sockets for the machine
       * running the node with the given name.
       *
       * Note that this method will return 1 on operating systems where
       * this can't be automatically determined and where the
       * IceGrid.Node.ProcessorSocketCount property for the node is not
       * set.
       *
       * @param name The node name.
       *
       * @return The number of processor sockets or 1 if the number of
       * sockets can't determined.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      getNodeProcessorSocketCount(
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<number>;

      /**
       * Shutdown an IceGrid node.
       *
       * @param name The node name.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      shutdownNode(name: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Get the hostname of this node.
       *
       * @param name The node name.
       *
       * @return The node hostname.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      getNodeHostname(name: string, ctx?: Ice.Context): Ice.AsyncResult<string>;

      /**
       * Get all the IceGrid nodes currently registered.
       *
       * @return The node names.
       */
      getAllNodeNames(ctx?: Ice.Context): Ice.AsyncResult<Ice.StringSeq>;

      /**
       * Ping an IceGrid registry to see if it is active.
       *
       * @param name The registry name.
       *
       * @return true if the registry ping succeeded, false otherwise.
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       */
      pingRegistry(name: string, ctx?: Ice.Context): Ice.AsyncResult<boolean>;

      /**
       * Get the registry information for the registry with the given name.
       *
       * @param name The registry name.
       *
       * @return The registry information.
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry could not be
       * reached.
       */
      getRegistryInfo(
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<RegistryInfo>;

      /**
       * Get a proxy to the IceGrid registry's admin object.
       *
       * @param name The registry name
       *
       * @return A proxy to the IceGrid registry's admin object
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       */
      getRegistryAdmin(
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Shutdown an IceGrid registry.
       *
       * @param name The registry name.
       *
       * @throws RegistryNotExistException Raised if the registry doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry could not be
       * reached.
       */
      shutdownRegistry(name: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Get all the IceGrid registries currently registered.
       *
       * @return The registry names.
       */
      getAllRegistryNames(ctx?: Ice.Context): Ice.AsyncResult<Ice.StringSeq>;

      /**
       * Shut down the IceGrid registry.
       */
      shutdown(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Returns the checksums for the IceGrid Slice definitions.
       *
       * @return A dictionary mapping Slice type ids to their checksums.
       */
      getSliceChecksums(
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.SliceChecksumDict>;
    }

    /**
     * This interface provides access to IceGrid log file contents.
     */
    abstract class FileIterator extends Ice.Object {
      /**
       * Read lines from the log file.
       *
       * @param size Specifies the maximum number of bytes to be
       * received. The server will ensure that the returned message
       * doesn't exceed the given size.
       *
       * @param lines The lines read from the file. If there was nothing to
       * read from the file since the last call to read, an empty
       * sequence is returned. The last line of the sequence is always
       * incomplete (and therefore no '\\\\n' should be added when writing
       * the last line to the to the output device).
       *
       * @return True if EOF is encountered.
       *
       * @throws FileNotAvailableException Raised if there was a problem
       * to read lines from the file.
       */
      abstract read(
        size: number,
        current: Ice.Current
      ): Ice.OperationResult<[boolean, Ice.StringSeq]>;

      /**
       * Destroy the iterator.
       */
      abstract destroy(current: Ice.Current): Ice.OperationResult<void>;
    }

    /**
     * This interface provides access to IceGrid log file contents.
     */
    class FileIteratorPrx extends Ice.ObjectPrx {
      /**
       * Read lines from the log file.
       *
       * @param size Specifies the maximum number of bytes to be
       * received. The server will ensure that the returned message
       * doesn't exceed the given size.
       *
       * @param lines The lines read from the file. If there was nothing to
       * read from the file since the last call to read, an empty
       * sequence is returned. The last line of the sequence is always
       * incomplete (and therefore no '\\\\n' should be added when writing
       * the last line to the to the output device).
       *
       * @return True if EOF is encountered.
       *
       * @throws FileNotAvailableException Raised if there was a problem
       * to read lines from the file.
       */
      read(
        size: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<[boolean, Ice.StringSeq]>;

      /**
       * Destroy the iterator.
       */
      destroy(ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * Dynamic information about the state of a server.
     */
    class ServerDynamicInfo implements Ice.Struct {
      constructor(
        id?: string,
        state?: ServerState,
        pid?: number,
        enabled?: boolean
      );

      /**
       * The id of the server.
       */
      id: string;

      /**
       * The state of the server.
       */
      state: ServerState;

      /**
       * The process id of the server.
       */
      pid: number;

      /**
       * Indicates whether the server is enabled.
       */
      enabled: boolean;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of server dynamic information structures.
     */
    type ServerDynamicInfoSeq = Array<ServerDynamicInfo>;

    /**
     * Dynamic information about the state of an adapter.
     */
    class AdapterDynamicInfo implements Ice.Struct {
      constructor(id?: string, proxy?: Ice.ObjectPrx | null);

      /**
       * The id of the adapter.
       */
      id: string;

      /**
       * The direct proxy containing the adapter endpoints.
       */
      proxy: Ice.ObjectPrx | null;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of adapter dynamic information structures.
     */
    type AdapterDynamicInfoSeq = Array<AdapterDynamicInfo>;

    /**
     * Dynamic information about the state of a node.
     */
    class NodeDynamicInfo implements Ice.Struct {
      constructor(
        info?: NodeInfo,
        servers?: ServerDynamicInfoSeq,
        adapters?: AdapterDynamicInfoSeq
      );

      /**
       * Some static information about the node.
       */
      info: NodeInfo;

      /**
       * The dynamic information of the servers deployed on this node.
       */
      servers: ServerDynamicInfoSeq;

      /**
       * The dynamic information of the adapters deployed on this node.
       */
      adapters: AdapterDynamicInfoSeq;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * This interface allows applications to monitor changes the state
     * of the registry.
     */
    abstract class RegistryObserver extends Ice.Object {
      /**
       * The <tt>registryInit</tt> operation is called after registration of
       * an observer to indicate the state of the registries.
       *
       * @param registries The current state of the registries.
       */
      abstract registryInit(
        registries: RegistryInfoSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>nodeUp</tt> operation is called to notify an observer that a node
       * came up.
       *
       * @param node The node state.
       */
      abstract registryUp(
        node: RegistryInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>nodeDown</tt> operation is called to notify an observer that a node
       * went down.
       *
       * @param name The node name.
       */
      abstract registryDown(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * This interface allows applications to monitor changes the state
     * of the registry.
     */
    class RegistryObserverPrx extends Ice.ObjectPrx {
      /**
       * The <tt>registryInit</tt> operation is called after registration of
       * an observer to indicate the state of the registries.
       *
       * @param registries The current state of the registries.
       */
      registryInit(
        registries: RegistryInfoSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>nodeUp</tt> operation is called to notify an observer that a node
       * came up.
       *
       * @param node The node state.
       */
      registryUp(node: RegistryInfo, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * The <tt>nodeDown</tt> operation is called to notify an observer that a node
       * went down.
       *
       * @param name The node name.
       */
      registryDown(name: string, ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * A sequence of node dynamic information structures.
     */
    type NodeDynamicInfoSeq = Array<NodeDynamicInfo>;

    /**
     * The node observer interface. Observers should implement this
     * interface to receive information about the state of the IceGrid
     * nodes.
     */
    abstract class NodeObserver extends Ice.Object {
      /**
       * The <tt>nodeInit</tt> operation indicates the current state
       * of nodes. It is called after the registration of an observer.
       *
       * @param nodes The current state of the nodes.
       */
      abstract nodeInit(
        nodes: NodeDynamicInfoSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>nodeUp</tt> operation is called to notify an observer that a node
       * came up.
       *
       * @param node The node state.
       */
      abstract nodeUp(
        node: NodeDynamicInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>nodeDown</tt> operation is called to notify an observer that a node
       * went down.
       *
       * @param name The node name.
       */
      abstract nodeDown(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>updateServer</tt> operation is called to notify an observer that
       * the state of a server changed.
       *
       * @param node The node hosting the server.
       *
       * @param updatedInfo The new server state.
       */
      abstract updateServer(
        node: string,
        updatedInfo: ServerDynamicInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>updateAdapter</tt> operation is called to notify an observer that
       * the state of an adapter changed.
       *
       * @param node The node hosting the adapter.
       *
       * @param updatedInfo The new adapter state.
       */
      abstract updateAdapter(
        node: string,
        updatedInfo: AdapterDynamicInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * The node observer interface. Observers should implement this
     * interface to receive information about the state of the IceGrid
     * nodes.
     */
    class NodeObserverPrx extends Ice.ObjectPrx {
      /**
       * The <tt>nodeInit</tt> operation indicates the current state
       * of nodes. It is called after the registration of an observer.
       *
       * @param nodes The current state of the nodes.
       */
      nodeInit(
        nodes: NodeDynamicInfoSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>nodeUp</tt> operation is called to notify an observer that a node
       * came up.
       *
       * @param node The node state.
       */
      nodeUp(node: NodeDynamicInfo, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * The <tt>nodeDown</tt> operation is called to notify an observer that a node
       * went down.
       *
       * @param name The node name.
       */
      nodeDown(name: string, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * The <tt>updateServer</tt> operation is called to notify an observer that
       * the state of a server changed.
       *
       * @param node The node hosting the server.
       *
       * @param updatedInfo The new server state.
       */
      updateServer(
        node: string,
        updatedInfo: ServerDynamicInfo,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>updateAdapter</tt> operation is called to notify an observer that
       * the state of an adapter changed.
       *
       * @param node The node hosting the adapter.
       *
       * @param updatedInfo The new adapter state.
       */
      updateAdapter(
        node: string,
        updatedInfo: AdapterDynamicInfo,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }

    /**
     * The database observer interface. Observers should implement this
     * interface to receive information about the state of the IceGrid
     * registry database.
     */
    abstract class ApplicationObserver extends Ice.Object {
      /**
       * <tt>applicationInit</tt> is called after the registration
       * of an observer to indicate the state of the registry.
       *
       * @param serial The current serial number of the registry
       * database. This serial number allows observers to make sure that
       * their internal state is synchronized with the registry.
       *
       * @param applications The applications currently registered with
       * the registry.
       */
      abstract applicationInit(
        serial: number,
        applications: ApplicationInfoSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>applicationAdded</tt> operation is called to notify an observer
       * that an application was added.
       *
       * @param serial The new serial number of the registry database.
       *
       * @param desc The descriptor of the new application.
       */
      abstract applicationAdded(
        serial: number,
        desc: ApplicationInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>applicationRemoved</tt> operation is called to notify an observer
       * that an application was removed.
       *
       * @param serial The new serial number of the registry database.
       *
       * @param name The name of the application that was removed.
       */
      abstract applicationRemoved(
        serial: number,
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>applicationUpdated</tt> operation is called to notify an observer
       * that an application was updated.
       *
       * @param serial The new serial number of the registry database.
       *
       * @param desc The descriptor of the update.
       */
      abstract applicationUpdated(
        serial: number,
        desc: ApplicationUpdateInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * The database observer interface. Observers should implement this
     * interface to receive information about the state of the IceGrid
     * registry database.
     */
    class ApplicationObserverPrx extends Ice.ObjectPrx {
      /**
       * <tt>applicationInit</tt> is called after the registration
       * of an observer to indicate the state of the registry.
       *
       * @param serial The current serial number of the registry
       * database. This serial number allows observers to make sure that
       * their internal state is synchronized with the registry.
       *
       * @param applications The applications currently registered with
       * the registry.
       */
      applicationInit(
        serial: number,
        applications: ApplicationInfoSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>applicationAdded</tt> operation is called to notify an observer
       * that an application was added.
       *
       * @param serial The new serial number of the registry database.
       *
       * @param desc The descriptor of the new application.
       */
      applicationAdded(
        serial: number,
        desc: ApplicationInfo,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>applicationRemoved</tt> operation is called to notify an observer
       * that an application was removed.
       *
       * @param serial The new serial number of the registry database.
       *
       * @param name The name of the application that was removed.
       */
      applicationRemoved(
        serial: number,
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>applicationUpdated</tt> operation is called to notify an observer
       * that an application was updated.
       *
       * @param serial The new serial number of the registry database.
       *
       * @param desc The descriptor of the update.
       */
      applicationUpdated(
        serial: number,
        desc: ApplicationUpdateInfo,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }

    /**
     * This interface allows applications to monitor the state of object
     * adapters that are registered with IceGrid.
     */
    abstract class AdapterObserver extends Ice.Object {
      /**
       * <tt>adapterInit</tt> is called after registration of
       * an observer to indicate the state of the registry.
       *
       * @param adpts The adapters that were dynamically registered
       * with the registry (not through the deployment mechanism).
       */
      abstract adapterInit(
        adpts: AdapterInfoSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>adapterAdded</tt> operation is called to notify an observer when
       * a dynamically-registered adapter was added.
       *
       * @param info The details of the new adapter.
       */
      abstract adapterAdded(
        info: AdapterInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The adapterUpdated operation is called to notify an observer when
       * a dynamically-registered adapter was updated.
       *
       * @param info The details of the updated adapter.
       */
      abstract adapterUpdated(
        info: AdapterInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The adapterRemoved operation is called to notify an observer when
       * a dynamically-registered adapter was removed.
       *
       * @param id The ID of the removed adapter.
       */
      abstract adapterRemoved(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * This interface allows applications to monitor the state of object
     * adapters that are registered with IceGrid.
     */
    class AdapterObserverPrx extends Ice.ObjectPrx {
      /**
       * <tt>adapterInit</tt> is called after registration of
       * an observer to indicate the state of the registry.
       *
       * @param adpts The adapters that were dynamically registered
       * with the registry (not through the deployment mechanism).
       */
      adapterInit(
        adpts: AdapterInfoSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>adapterAdded</tt> operation is called to notify an observer when
       * a dynamically-registered adapter was added.
       *
       * @param info The details of the new adapter.
       */
      adapterAdded(info: AdapterInfo, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * The adapterUpdated operation is called to notify an observer when
       * a dynamically-registered adapter was updated.
       *
       * @param info The details of the updated adapter.
       */
      adapterUpdated(
        info: AdapterInfo,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The adapterRemoved operation is called to notify an observer when
       * a dynamically-registered adapter was removed.
       *
       * @param id The ID of the removed adapter.
       */
      adapterRemoved(id: string, ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * This interface allows applications to monitor IceGrid well-known objects.
     */
    abstract class ObjectObserver extends Ice.Object {
      /**
       * <tt>objectInit</tt> is called after the registration of
       * an observer to indicate the state of the registry.
       *
       * @param objects The objects registered with the {@link Admin}
       * interface (not through the deployment mechanism).
       */
      abstract objectInit(
        objects: ObjectInfoSeq,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * The <tt>objectAdded</tt> operation is called to notify an observer when an
       * object was added to the {@link Admin} interface.
       *
       * @param info The details of the added object.
       */
      abstract objectAdded(
        info: ObjectInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * <tt>objectUpdated</tt> is called to notify an observer when
       * an object registered with the {@link Admin} interface was updated.
       *
       * @param info The details of the updated object.
       */
      abstract objectUpdated(
        info: ObjectInfo,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * <tt>objectRemoved</tt> is called to notify an observer when
       * an object registered with the {@link Admin} interface was removed.
       *
       * @param id The identity of the removed object.
       */
      abstract objectRemoved(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * This interface allows applications to monitor IceGrid well-known objects.
     */
    class ObjectObserverPrx extends Ice.ObjectPrx {
      /**
       * <tt>objectInit</tt> is called after the registration of
       * an observer to indicate the state of the registry.
       *
       * @param objects The objects registered with the {@link Admin}
       * interface (not through the deployment mechanism).
       */
      objectInit(
        objects: ObjectInfoSeq,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * The <tt>objectAdded</tt> operation is called to notify an observer when an
       * object was added to the {@link Admin} interface.
       *
       * @param info The details of the added object.
       */
      objectAdded(info: ObjectInfo, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * <tt>objectUpdated</tt> is called to notify an observer when
       * an object registered with the {@link Admin} interface was updated.
       *
       * @param info The details of the updated object.
       */
      objectUpdated(info: ObjectInfo, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * <tt>objectRemoved</tt> is called to notify an observer when
       * an object registered with the {@link Admin} interface was removed.
       *
       * @param id The identity of the removed object.
       */
      objectRemoved(id: Ice.Identity, ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * Used by administrative clients to view,
     * update, and receive observer updates from the IceGrid
     * registry. Admin sessions are created either via the {@link Registry}
     * object or via the registry admin <tt>SessionManager</tt> object.
     *
     * @see Registry
     */
    abstract class AdminSession extends Ice.Object implements Glacier2.Session {
      /**
       * Destroy the session. This is called automatically when the router is destroyed.
       */
      abstract destroy(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Keep the session alive. Clients should call this operation
       * regularly to prevent the server from reaping the session.
       *
       * @see Registry#getSessionTimeout
       */
      abstract keepAlive(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Get the admin interface. The admin object returned by this
       * operation can only be accessed by the session.
       *
       * @return The admin interface proxy.
       */
      abstract getAdmin(
        current: Ice.Current
      ): Ice.OperationResult<AdminPrx | null>;

      /**
       * Get a \\"template\\" proxy for admin callback objects.
       * An Admin client uses this proxy to set the category of its callback
       * objects, and the published endpoints of the object adapter hosting
       * the admin callback objects.
       *
       * @return A template proxy. The returned proxy is null when the Admin
       * session was established using Glacier2.
       */
      abstract getAdminCallbackTemplate(
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Set the observer proxies that receive
       * notifications when the state of the registry
       * or nodes changes.
       *
       * @param registryObs The registry observer.
       *
       * @param nodeObs The node observer.
       *
       * @param appObs The application observer.
       *
       * @param adptObs The adapter observer.
       *
       * @param objObs The object observer.
       *
       * @throws ObserverAlreadyRegisteredException Raised if an
       * observer is already registered with this registry.
       */
      abstract setObservers(
        registryObs: RegistryObserverPrx | null,
        nodeObs: NodeObserverPrx | null,
        appObs: ApplicationObserverPrx | null,
        adptObs: AdapterObserverPrx | null,
        objObs: ObjectObserverPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Set the observer identities that receive
       * notifications the state of the registry
       * or nodes changes. This operation should be used by clients that
       * are using a bidirectional connection to communicate with the
       * session.
       *
       * @param registryObs The registry observer identity.
       *
       * @param nodeObs The node observer identity.
       *
       * @param appObs The application observer.
       *
       * @param adptObs The adapter observer.
       *
       * @param objObs The object observer.
       *
       * @throws ObserverAlreadyRegisteredException Raised if an
       * observer is already registered with this registry.
       */
      abstract setObserversByIdentity(
        registryObs: Ice.Identity,
        nodeObs: Ice.Identity,
        appObs: Ice.Identity,
        adptObs: Ice.Identity,
        objObs: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Acquires an exclusive lock to start updating the registry applications.
       *
       * @return The current serial.
       *
       * @throws AccessDeniedException Raised if the exclusive lock can't be
       * acquired. This might happen if the lock is currently acquired by
       * another session.
       */
      abstract startUpdate(current: Ice.Current): Ice.OperationResult<number>;

      /**
       * Finish updating the registry and release the exclusive lock.
       *
       * @throws AccessDeniedException Raised if the session doesn't hold the
       * exclusive lock.
       */
      abstract finishUpdate(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Get the name of the registry replica hosting this session.
       *
       * @return The replica name of the registry.
       */
      abstract getReplicaName(
        current: Ice.Current
      ): Ice.OperationResult<string>;

      /**
       * Open the given server log file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param id The server id.
       *
       * @param path The path of the log file. A log file can be opened
       * only if it's declared in the server or service deployment
       * descriptor.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract openServerLog(
        id: string,
        path: string,
        count: number,
        current: Ice.Current
      ): Ice.OperationResult<FileIteratorPrx | null>;

      /**
       * Open the given server stderr file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param id The server id.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract openServerStdErr(
        id: string,
        count: number,
        current: Ice.Current
      ): Ice.OperationResult<FileIteratorPrx | null>;

      /**
       * Open the given server stdout file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param id The server id.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      abstract openServerStdOut(
        id: string,
        count: number,
        current: Ice.Current
      ): Ice.OperationResult<FileIteratorPrx | null>;

      /**
       * Open the given node stderr file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The node name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       */
      abstract openNodeStdErr(
        name: string,
        count: number,
        current: Ice.Current
      ): Ice.OperationResult<FileIteratorPrx | null>;

      /**
       * Open the given node stdout file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The node name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       */
      abstract openNodeStdOut(
        name: string,
        count: number,
        current: Ice.Current
      ): Ice.OperationResult<FileIteratorPrx | null>;

      /**
       * Open the given registry stderr file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The registry name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws RegistryNotExistException Raised if the registry
       * doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry
       * could not be reached.
       */
      abstract openRegistryStdErr(
        name: string,
        count: number,
        current: Ice.Current
      ): Ice.OperationResult<FileIteratorPrx | null>;

      /**
       * Open the given registry stdout file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The registry name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws RegistryNotExistException Raised if the registry
       * doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry
       * could not be reached.
       */
      abstract openRegistryStdOut(
        name: string,
        count: number,
        current: Ice.Current
      ): Ice.OperationResult<FileIteratorPrx | null>;
    }

    /**
     * Used by administrative clients to view,
     * update, and receive observer updates from the IceGrid
     * registry. Admin sessions are created either via the {@link Registry}
     * object or via the registry admin <tt>SessionManager</tt> object.
     *
     * @see Registry
     */
    class AdminSessionPrx extends Ice.ObjectPrx implements Glacier2.SessionPrx {
      /**
       * Destroy the session. This is called automatically when the router is destroyed.
       */
      destroy(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Keep the session alive. Clients should call this operation
       * regularly to prevent the server from reaping the session.
       *
       * @see Registry#getSessionTimeout
       */
      keepAlive(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Get the admin interface. The admin object returned by this
       * operation can only be accessed by the session.
       *
       * @return The admin interface proxy.
       */
      getAdmin(ctx?: Ice.Context): Ice.AsyncResult<AdminPrx | null>;

      /**
       * Get a \\"template\\" proxy for admin callback objects.
       * An Admin client uses this proxy to set the category of its callback
       * objects, and the published endpoints of the object adapter hosting
       * the admin callback objects.
       *
       * @return A template proxy. The returned proxy is null when the Admin
       * session was established using Glacier2.
       */
      getAdminCallbackTemplate(
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Set the observer proxies that receive
       * notifications when the state of the registry
       * or nodes changes.
       *
       * @param registryObs The registry observer.
       *
       * @param nodeObs The node observer.
       *
       * @param appObs The application observer.
       *
       * @param adptObs The adapter observer.
       *
       * @param objObs The object observer.
       *
       * @throws ObserverAlreadyRegisteredException Raised if an
       * observer is already registered with this registry.
       */
      setObservers(
        registryObs: RegistryObserverPrx | null,
        nodeObs: NodeObserverPrx | null,
        appObs: ApplicationObserverPrx | null,
        adptObs: AdapterObserverPrx | null,
        objObs: ObjectObserverPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Set the observer identities that receive
       * notifications the state of the registry
       * or nodes changes. This operation should be used by clients that
       * are using a bidirectional connection to communicate with the
       * session.
       *
       * @param registryObs The registry observer identity.
       *
       * @param nodeObs The node observer identity.
       *
       * @param appObs The application observer.
       *
       * @param adptObs The adapter observer.
       *
       * @param objObs The object observer.
       *
       * @throws ObserverAlreadyRegisteredException Raised if an
       * observer is already registered with this registry.
       */
      setObserversByIdentity(
        registryObs: Ice.Identity,
        nodeObs: Ice.Identity,
        appObs: Ice.Identity,
        adptObs: Ice.Identity,
        objObs: Ice.Identity,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Acquires an exclusive lock to start updating the registry applications.
       *
       * @return The current serial.
       *
       * @throws AccessDeniedException Raised if the exclusive lock can't be
       * acquired. This might happen if the lock is currently acquired by
       * another session.
       */
      startUpdate(ctx?: Ice.Context): Ice.AsyncResult<number>;

      /**
       * Finish updating the registry and release the exclusive lock.
       *
       * @throws AccessDeniedException Raised if the session doesn't hold the
       * exclusive lock.
       */
      finishUpdate(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Get the name of the registry replica hosting this session.
       *
       * @return The replica name of the registry.
       */
      getReplicaName(ctx?: Ice.Context): Ice.AsyncResult<string>;

      /**
       * Open the given server log file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param id The server id.
       *
       * @param path The path of the log file. A log file can be opened
       * only if it's declared in the server or service deployment
       * descriptor.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      openServerLog(
        id: string,
        path: string,
        count: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileIteratorPrx | null>;

      /**
       * Open the given server stderr file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param id The server id.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      openServerStdErr(
        id: string,
        count: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileIteratorPrx | null>;

      /**
       * Open the given server stdout file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param id The server id.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws ServerNotExistException Raised if the server doesn't
       * exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       *
       * @throws DeploymentException Raised if the server couldn't be
       * deployed on the node.
       */
      openServerStdOut(
        id: string,
        count: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileIteratorPrx | null>;

      /**
       * Open the given node stderr file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The node name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       */
      openNodeStdErr(
        name: string,
        count: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileIteratorPrx | null>;

      /**
       * Open the given node stdout file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The node name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not
       * be reached.
       */
      openNodeStdOut(
        name: string,
        count: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileIteratorPrx | null>;

      /**
       * Open the given registry stderr file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The registry name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws RegistryNotExistException Raised if the registry
       * doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry
       * could not be reached.
       */
      openRegistryStdErr(
        name: string,
        count: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileIteratorPrx | null>;

      /**
       * Open the given registry stdout file for reading. The file can be
       * read with the returned file iterator.
       *
       * @param name The registry name.
       *
       * @param count Specifies where to start reading the file. If
       * negative, the file is read from the begining. If 0 or positive,
       * the file is read from the last <tt>count</tt> lines.
       *
       * @return An iterator to read the file.
       *
       * @throws FileNotAvailableException Raised if the file can't be
       * read.
       *
       * @throws RegistryNotExistException Raised if the registry
       * doesn't exist.
       *
       * @throws RegistryUnreachableException Raised if the registry
       * could not be reached.
       */
      openRegistryStdOut(
        name: string,
        count: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileIteratorPrx | null>;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 53`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Identity\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    /**
     * A mapping of string to string.
     */
    type StringStringDict = Map<string, string>;

    /**
     * Property descriptor.
     */
    class PropertyDescriptor implements Ice.Struct {
      constructor(name?: string, value?: string);

      /**
       * The name of the property.
       */
      name: string;

      /**
       * The value of the property.
       */
      value: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of property descriptors.
     */
    type PropertyDescriptorSeq = Array<PropertyDescriptor>;

    /**
     * A property set descriptor.
     */
    class PropertySetDescriptor implements Ice.Struct {
      constructor(
        references?: Ice.StringSeq,
        properties?: PropertyDescriptorSeq
      );

      /**
       * References to named property sets.
       */
      references: Ice.StringSeq;

      /**
       * The property set properties.
       */
      properties: PropertyDescriptorSeq;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A mapping of property set name to property set descriptor.
     */
    type PropertySetDescriptorDict = Map<string, PropertySetDescriptor>;

    /**
     * An Ice object descriptor.
     */
    class ObjectDescriptor implements Ice.Struct {
      constructor(id?: Ice.Identity, type?: string, proxyOptions?: string);

      /**
       * The identity of the object.
       */
      id: Ice.Identity;

      /**
       * The object type.
       */
      type: string;

      /**
       * Proxy options to use with the proxy created for this Ice object. If empty,
       * the proxy will be created with the proxy options specified on the object
       * adapter or replica group.
       */
      proxyOptions: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of object descriptors.
     */
    type ObjectDescriptorSeq = Array<ObjectDescriptor>;

    /**
     * An Ice object adapter descriptor.
     */
    class AdapterDescriptor implements Ice.Struct {
      constructor(
        name?: string,
        description?: string,
        id?: string,
        replicaGroupId?: string,
        priority?: string,
        registerProcess?: boolean,
        serverLifetime?: boolean,
        objects?: ObjectDescriptorSeq,
        allocatables?: ObjectDescriptorSeq
      );

      /**
       * The object adapter name.
       */
      name: string;

      /**
       * The description of this object adapter.
       */
      description: string;

      /**
       * The object adapter id.
       */
      id: string;

      /**
       * The replica id of this adapter.
       */
      replicaGroupId: string;

      /**
       * The adapter priority. This is eventually used when the adapter
       * is member of a replica group to sort the adapter endpoints by
       * priority.
       */
      priority: string;

      /**
       * Flag to specify if the object adapter will register a process object.
       */
      registerProcess: boolean;

      /**
       * If true the lifetime of this object adapter is the same of the
       * server lifetime. This information is used by the IceGrid node
       * to figure out the server state: the server is active only if
       * all its \\"server lifetime\\" adapters are active.
       */
      serverLifetime: boolean;

      /**
       * The well-known object descriptors associated with this object adapter.
       */
      objects: ObjectDescriptorSeq;

      /**
       * The allocatable object descriptors associated with this object adapter.
       */
      allocatables: ObjectDescriptorSeq;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of adapter descriptors.
     */
    type AdapterDescriptorSeq = Array<AdapterDescriptor>;

    /**
     * A Freeze database environment descriptor.
     */
    class DbEnvDescriptor implements Ice.Struct {
      constructor(
        name?: string,
        description?: string,
        dbHome?: string,
        properties?: PropertyDescriptorSeq
      );

      /**
       * The name of the database environment.
       */
      name: string;

      /**
       * The description of this database environment.
       */
      description: string;

      /**
       * The home of the database environment (i.e., the directory where
       * the database files will be stored). If empty, the node will
       * provide a default database directory, otherwise the directory
       * must exist.
       */
      dbHome: string;

      /**
       * The configuration properties of the database environment.
       */
      properties: PropertyDescriptorSeq;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of database environment descriptors.
     */
    type DbEnvDescriptorSeq = Array<DbEnvDescriptor>;

    /**
     * A communicator descriptor.
     */
    class CommunicatorDescriptor extends Ice.Value {
      constructor(
        adapters?: AdapterDescriptorSeq,
        propertySet?: PropertySetDescriptor,
        dbEnvs?: DbEnvDescriptorSeq,
        logs?: Ice.StringSeq,
        description?: string
      );

      /**
       * The object adapters.
       */
      adapters: AdapterDescriptorSeq;

      /**
       * The property set.
       */
      propertySet: PropertySetDescriptor;

      /**
       * The database environments.
       */
      dbEnvs: DbEnvDescriptorSeq;

      /**
       * The path of each log file.
       */
      logs: Ice.StringSeq;

      /**
       * A description of this descriptor.
       */
      description: string;
    }

    /**
     * A distribution descriptor defines an IcePatch2 server and the
     * directories to retrieve from the patch server.
     */
    class DistributionDescriptor implements Ice.Struct {
      constructor(icepatch?: string, directories?: Ice.StringSeq);

      icepatch: string;
      directories: Ice.StringSeq;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * An Ice server descriptor.
     */
    class ServerDescriptor extends CommunicatorDescriptor {
      constructor(
        adapters?: AdapterDescriptorSeq,
        propertySet?: PropertySetDescriptor,
        dbEnvs?: DbEnvDescriptorSeq,
        logs?: Ice.StringSeq,
        description?: string,
        id?: string,
        exe?: string,
        iceVersion?: string,
        pwd?: string,
        options?: Ice.StringSeq,
        envs?: Ice.StringSeq,
        activation?: string,
        activationTimeout?: string,
        deactivationTimeout?: string,
        applicationDistrib?: boolean,
        distrib?: DistributionDescriptor,
        allocatable?: boolean,
        user?: string
      );

      /**
       * The server id.
       */
      id: string;

      /**
       * The path of the server executable.
       */
      exe: string;

      /**
       * The Ice version used by this server. This is only required if
       * backward compatibility with servers using old Ice versions is
       * needed (otherwise the registry will assume the server is using
       * the same Ice version).
       * For example \\"3.1.1\\", \\"3.2\\", \\"3.3.0\\".
       */
      iceVersion: string;

      /**
       * The path to the server working directory.
       */
      pwd: string;

      /**
       * The command line options to pass to the server executable.
       */
      options: Ice.StringSeq;

      /**
       * The server environment variables.
       */
      envs: Ice.StringSeq;

      /**
       * The server activation mode (possible values are \\"on-demand\\" or
       * \\"manual\\").
       */
      activation: string;

      /**
       * The activation timeout (an integer value representing the
       * number of seconds to wait for activation).
       */
      activationTimeout: string;

      /**
       * The deactivation timeout (an integer value representing the
       * number of seconds to wait for deactivation).
       */
      deactivationTimeout: string;

      /**
       * Specifies if the server depends on the application
       * distribution.
       */
      applicationDistrib: boolean;

      /**
       * The distribution descriptor.
       */
      distrib: DistributionDescriptor;

      /**
       * Specifies if the server is allocatable.
       */
      allocatable: boolean;

      /**
       * The user account used to run the server.
       */
      user: string;
    }

    /**
     * A sequence of server descriptors.
     */
    type ServerDescriptorSeq = Array<ServerDescriptor | null>;

    /**
     * An IceBox service descriptor.
     */
    class ServiceDescriptor extends CommunicatorDescriptor {
      constructor(
        adapters?: AdapterDescriptorSeq,
        propertySet?: PropertySetDescriptor,
        dbEnvs?: DbEnvDescriptorSeq,
        logs?: Ice.StringSeq,
        description?: string,
        name?: string,
        entry?: string
      );

      /**
       * The service name.
       */
      name: string;

      /**
       * The entry point of the IceBox service.
       */
      entry: string;
    }

    /**
     * A sequence of service descriptors.
     */
    type ServiceDescriptorSeq = Array<ServiceDescriptor | null>;

    /**
     * A server template instance descriptor.
     */
    class ServerInstanceDescriptor implements Ice.Struct {
      constructor(
        template?: string,
        parameterValues?: StringStringDict,
        propertySet?: PropertySetDescriptor,
        servicePropertySets?: PropertySetDescriptorDict
      );

      /**
       * The template used by this instance.
       */
      template: string;

      /**
       * The template parameter values.
       */
      parameterValues: StringStringDict;

      /**
       * The property set.
       */
      propertySet: PropertySetDescriptor;

      /**
       * The services property sets. It's only valid to set these
       * property sets if the template is an IceBox server template.
       */
      servicePropertySets: PropertySetDescriptorDict;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of server instance descriptors.
     */
    type ServerInstanceDescriptorSeq = Array<ServerInstanceDescriptor>;

    /**
     * A template descriptor for server or service templates.
     */
    class TemplateDescriptor implements Ice.Struct {
      constructor(
        descriptor?: CommunicatorDescriptor | null,
        parameters?: Ice.StringSeq,
        parameterDefaults?: StringStringDict
      );

      /**
       * The template.
       */
      descriptor: CommunicatorDescriptor | null;

      /**
       * The parameters required to instantiate the template.
       */
      parameters: Ice.StringSeq;

      /**
       * The parameters default values.
       */
      parameterDefaults: StringStringDict;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A mapping of template identifier to template descriptor.
     */
    type TemplateDescriptorDict = Map<string, TemplateDescriptor>;

    /**
     * A service template instance descriptor.
     */
    class ServiceInstanceDescriptor implements Ice.Struct {
      constructor(
        template?: string,
        parameterValues?: StringStringDict,
        descriptor?: ServiceDescriptor | null,
        propertySet?: PropertySetDescriptor
      );

      /**
       * The template used by this instance.
       */
      template: string;

      /**
       * The template parameter values.
       */
      parameterValues: StringStringDict;

      /**
       * The service definition if the instance isn't a template
       * instance (i.e.: if the template attribute is empty).
       */
      descriptor: ServiceDescriptor | null;

      /**
       * The property set.
       */
      propertySet: PropertySetDescriptor;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of service instance descriptors.
     */
    type ServiceInstanceDescriptorSeq = Array<ServiceInstanceDescriptor>;

    /**
     * An IceBox server descriptor.
     */
    class IceBoxDescriptor extends ServerDescriptor {
      constructor(
        adapters?: AdapterDescriptorSeq,
        propertySet?: PropertySetDescriptor,
        dbEnvs?: DbEnvDescriptorSeq,
        logs?: Ice.StringSeq,
        description?: string,
        id?: string,
        exe?: string,
        iceVersion?: string,
        pwd?: string,
        options?: Ice.StringSeq,
        envs?: Ice.StringSeq,
        activation?: string,
        activationTimeout?: string,
        deactivationTimeout?: string,
        applicationDistrib?: boolean,
        distrib?: DistributionDescriptor,
        allocatable?: boolean,
        user?: string,
        services?: ServiceInstanceDescriptorSeq
      );

      /**
       * The service instances.
       */
      services: ServiceInstanceDescriptorSeq;
    }

    /**
     * A node descriptor.
     */
    class NodeDescriptor implements Ice.Struct {
      constructor(
        variables?: StringStringDict,
        serverInstances?: ServerInstanceDescriptorSeq,
        servers?: ServerDescriptorSeq,
        loadFactor?: string,
        description?: string,
        propertySets?: PropertySetDescriptorDict
      );

      /**
       * The variables defined for the node.
       */
      variables: StringStringDict;

      /**
       * The server instances.
       */
      serverInstances: ServerInstanceDescriptorSeq;

      /**
       * Servers (which are not template instances).
       */
      servers: ServerDescriptorSeq;

      /**
       * Load factor of the node.
       */
      loadFactor: string;

      /**
       * The description of this node.
       */
      description: string;

      /**
       * Property set descriptors.
       */
      propertySets: PropertySetDescriptorDict;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * Mapping of node name to node descriptor.
     */
    type NodeDescriptorDict = Map<string, NodeDescriptor>;

    /**
     * A base class for load balancing policies.
     */
    class LoadBalancingPolicy extends Ice.Value {
      constructor(nReplicas?: string);

      /**
       * The number of replicas that will be used to gather the
       * endpoints of a replica group.
       */
      nReplicas: string;
    }

    /**
     * Random load balancing policy.
     */
    class RandomLoadBalancingPolicy extends LoadBalancingPolicy {}

    /**
     * Ordered load balancing policy.
     */
    class OrderedLoadBalancingPolicy extends LoadBalancingPolicy {}

    /**
     * Round robin load balancing policy.
     */
    class RoundRobinLoadBalancingPolicy extends LoadBalancingPolicy {}

    /**
     * Adaptive load balancing policy.
     */
    class AdaptiveLoadBalancingPolicy extends LoadBalancingPolicy {
      constructor(nReplicas?: string, loadSample?: string);

      /**
       * The load sample to use for the load balancing. The allowed
       * values for this attribute are \\"1\\", \\"5\\" and \\"15\\", representing
       * respectively the load average over the past minute, the past 5
       * minutes and the past 15 minutes.
       */
      loadSample: string;
    }

    /**
     * A replica group descriptor.
     */
    class ReplicaGroupDescriptor implements Ice.Struct {
      constructor(
        id?: string,
        loadBalancing?: LoadBalancingPolicy | null,
        proxyOptions?: string,
        objects?: ObjectDescriptorSeq,
        description?: string,
        filter?: string
      );

      /**
       * The id of the replica group.
       */
      id: string;

      /**
       * The load balancing policy.
       */
      loadBalancing: LoadBalancingPolicy | null;

      /**
       * Default options for proxies created for the replica group.
       */
      proxyOptions: string;

      /**
       * The object descriptors associated with this object adapter.
       */
      objects: ObjectDescriptorSeq;

      /**
       * The description of this replica group.
       */
      description: string;

      /**
       * The filter to use for this replica group.
       */
      filter: string;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of replica groups.
     */
    type ReplicaGroupDescriptorSeq = Array<ReplicaGroupDescriptor>;

    /**
     * An application descriptor.
     */
    class ApplicationDescriptor implements Ice.Struct {
      constructor(
        name?: string,
        variables?: StringStringDict,
        replicaGroups?: ReplicaGroupDescriptorSeq,
        serverTemplates?: TemplateDescriptorDict,
        serviceTemplates?: TemplateDescriptorDict,
        nodes?: NodeDescriptorDict,
        distrib?: DistributionDescriptor,
        description?: string,
        propertySets?: PropertySetDescriptorDict
      );

      /**
       * The application name.
       */
      name: string;

      /**
       * The variables defined in the application descriptor.
       */
      variables: StringStringDict;

      /**
       * The replica groups.
       */
      replicaGroups: ReplicaGroupDescriptorSeq;

      /**
       * The server templates.
       */
      serverTemplates: TemplateDescriptorDict;

      /**
       * The service templates.
       */
      serviceTemplates: TemplateDescriptorDict;

      /**
       * The application nodes.
       */
      nodes: NodeDescriptorDict;

      /**
       * The application distribution.
       */
      distrib: DistributionDescriptor;

      /**
       * The description of this application.
       */
      description: string;

      /**
       * Property set descriptors.
       */
      propertySets: PropertySetDescriptorDict;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of application descriptors.
     */
    type ApplicationDescriptorSeq = Array<ApplicationDescriptor>;

    /**
     * A \\"boxed\\" string.
     */
    class BoxedString extends Ice.Value {
      constructor(value?: string);

      value: string;
    }

    /**
     * A node update descriptor to describe the updates to apply to a
     * node of a deployed application.
     */
    class NodeUpdateDescriptor implements Ice.Struct {
      constructor(
        name?: string,
        description?: BoxedString | null,
        variables?: StringStringDict,
        removeVariables?: Ice.StringSeq,
        propertySets?: PropertySetDescriptorDict,
        removePropertySets?: Ice.StringSeq,
        serverInstances?: ServerInstanceDescriptorSeq,
        servers?: ServerDescriptorSeq,
        removeServers?: Ice.StringSeq,
        loadFactor?: BoxedString | null
      );

      /**
       * The name of the node to update.
       */
      name: string;

      /**
       * The updated description (or null if the description wasn't
       * updated.)
       */
      description: BoxedString | null;

      /**
       * The variables to update.
       */
      variables: StringStringDict;

      /**
       * The variables to remove.
       */
      removeVariables: Ice.StringSeq;

      /**
       * The property sets to update.
       */
      propertySets: PropertySetDescriptorDict;

      /**
       * The property sets to remove.
       */
      removePropertySets: Ice.StringSeq;

      /**
       * The server instances to update.
       */
      serverInstances: ServerInstanceDescriptorSeq;

      /**
       * The servers which are not template instances to update.
       */
      servers: ServerDescriptorSeq;

      /**
       * The ids of the servers to remove.
       */
      removeServers: Ice.StringSeq;

      /**
       * The updated load factor of the node (or null if the load factor
       * was not updated).
       */
      loadFactor: BoxedString | null;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of node update descriptors.
     */
    type NodeUpdateDescriptorSeq = Array<NodeUpdateDescriptor>;

    /**
     * A \\"boxed\\" distribution descriptor.
     */
    class BoxedDistributionDescriptor extends Ice.Value {
      constructor(value?: DistributionDescriptor);

      value: DistributionDescriptor;
    }

    /**
     * An application update descriptor to describe the updates to apply
     * to a deployed application.
     */
    class ApplicationUpdateDescriptor implements Ice.Struct {
      constructor(
        name?: string,
        description?: BoxedString | null,
        distrib?: BoxedDistributionDescriptor | null,
        variables?: StringStringDict,
        removeVariables?: Ice.StringSeq,
        propertySets?: PropertySetDescriptorDict,
        removePropertySets?: Ice.StringSeq,
        replicaGroups?: ReplicaGroupDescriptorSeq,
        removeReplicaGroups?: Ice.StringSeq,
        serverTemplates?: TemplateDescriptorDict,
        removeServerTemplates?: Ice.StringSeq,
        serviceTemplates?: TemplateDescriptorDict,
        removeServiceTemplates?: Ice.StringSeq,
        nodes?: NodeUpdateDescriptorSeq,
        removeNodes?: Ice.StringSeq
      );

      /**
       * The name of the application to update.
       */
      name: string;

      /**
       * The updated description (or null if the description wasn't
       * updated.)
       */
      description: BoxedString | null;

      /**
       * The updated distribution application descriptor.
       */
      distrib: BoxedDistributionDescriptor | null;

      /**
       * The variables to update.
       */
      variables: StringStringDict;

      /**
       * The variables to remove.
       */
      removeVariables: Ice.StringSeq;

      /**
       * The property sets to update.
       */
      propertySets: PropertySetDescriptorDict;

      /**
       * The property sets to remove.
       */
      removePropertySets: Ice.StringSeq;

      /**
       * The replica groups to update.
       */
      replicaGroups: ReplicaGroupDescriptorSeq;

      /**
       * The replica groups to remove.
       */
      removeReplicaGroups: Ice.StringSeq;

      /**
       * The server templates to update.
       */
      serverTemplates: TemplateDescriptorDict;

      /**
       * The ids of the server template to remove.
       */
      removeServerTemplates: Ice.StringSeq;

      /**
       * The service templates to update.
       */
      serviceTemplates: TemplateDescriptorDict;

      /**
       * The ids of the service template to remove.
       */
      removeServiceTemplates: Ice.StringSeq;

      /**
       * The application nodes to update.
       */
      nodes: NodeUpdateDescriptorSeq;

      /**
       * The nodes to remove.
       */
      removeNodes: Ice.StringSeq;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 54`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Identity\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    /**
     * This exception is raised if an application does not exist.
     */
    class ApplicationNotExistException extends Ice.UserException {
      constructor(name?: string);

      /**
       * The name of the application.
       */
      name: string;
    }

    /**
     * This exception is raised if a server does not exist.
     */
    class ServerNotExistException extends Ice.UserException {
      constructor(id?: string);

      id: string;
    }

    /**
     * This exception is raised if a server failed to start.
     */
    class ServerStartException extends Ice.UserException {
      constructor(id?: string, reason?: string);

      /**
       * The identifier of the server.
       */
      id: string;

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception is raised if a server failed to stop.
     */
    class ServerStopException extends Ice.UserException {
      constructor(id?: string, reason?: string);

      /**
       * The identifier of the server.
       */
      id: string;

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception is raised if an adapter does not exist.
     */
    class AdapterNotExistException extends Ice.UserException {
      constructor(id?: string);

      /**
       * The id of the object adapter.
       */
      id: string;
    }

    /**
     * This exception is raised if an object already exists.
     */
    class ObjectExistsException extends Ice.UserException {
      constructor(id?: Ice.Identity);

      /**
       * The identity of the object.
       */
      id: Ice.Identity;
    }

    /**
     * This exception is raised if an object is not registered.
     */
    class ObjectNotRegisteredException extends Ice.UserException {
      constructor(id?: Ice.Identity);

      /**
       * The identity of the object.
       */
      id: Ice.Identity;
    }

    /**
     * This exception is raised if a node does not exist.
     */
    class NodeNotExistException extends Ice.UserException {
      constructor(name?: string);

      /**
       * The node name.
       */
      name: string;
    }

    /**
     * This exception is raised if a registry does not exist.
     */
    class RegistryNotExistException extends Ice.UserException {
      constructor(name?: string);

      /**
       * The registry name.
       */
      name: string;
    }

    /**
     * An exception for deployment errors.
     */
    class DeploymentException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception is raised if a node could not be reached.
     */
    class NodeUnreachableException extends Ice.UserException {
      constructor(name?: string, reason?: string);

      /**
       * The name of the node that is not reachable.
       */
      name: string;

      /**
       * The reason why the node couldn't be reached.
       */
      reason: string;
    }

    /**
     * This exception is raised if a server could not be reached.
     */
    class ServerUnreachableException extends Ice.UserException {
      constructor(name?: string, reason?: string);

      /**
       * The id of the server that is not reachable.
       */
      name: string;

      /**
       * The reason why the server couldn't be reached.
       */
      reason: string;
    }

    /**
     * This exception is raised if a registry could not be reached.
     */
    class RegistryUnreachableException extends Ice.UserException {
      constructor(name?: string, reason?: string);

      /**
       * The name of the registry that is not reachable.
       */
      name: string;

      /**
       * The reason why the registry couldn't be reached.
       */
      reason: string;
    }

    /**
     * This exception is raised if an unknown signal was sent to
     * to a server.
     */
    class BadSignalException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The details of the unknown signal.
       */
      reason: string;
    }

    /**
     * This exception is raised if a patch failed.
     */
    class PatchException extends Ice.UserException {
      constructor(reasons?: Ice.StringSeq);

      /**
       * The reasons why the patch failed.
       */
      reasons: Ice.StringSeq;
    }

    /**
     * *
     * * This exception is raised if a registry lock wasn't
     *  * acquired or is already held by a session.
     * *
     */
    class AccessDeniedException extends Ice.UserException {
      constructor(lockUserId?: string);

      /**
       * The id of the user holding the lock (if any).
       */
      lockUserId: string;
    }

    /**
     * This exception is raised if the allocation of an object failed.
     */
    class AllocationException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason why the object couldn't be allocated.
       */
      reason: string;
    }

    /**
     * This exception is raised if the request to allocate an object times
     * out.
     */
    class AllocationTimeoutException extends AllocationException {}

    /**
     * This exception is raised if a client is denied the ability to create
     * a session with IceGrid.
     */
    class PermissionDeniedException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason why permission was denied.
       */
      reason: string;
    }

    /**
     * This exception is raised if an observer is already registered with
     * the registry.
     *
     * @see AdminSession#setObservers
     * @see AdminSession#setObserversByIdentity
     */
    class ObserverAlreadyRegisteredException extends Ice.UserException {
      constructor(id?: Ice.Identity);

      /**
       * The identity of the observer.
       */
      id: Ice.Identity;
    }

    /**
     * This exception is raised if a file is not available.
     *
     * @see AdminSession#openServerStdOut
     * @see AdminSession#openServerStdErr
     * @see AdminSession#openNodeStdOut
     * @see AdminSession#openNodeStdErr
     * @see AdminSession#openRegistryStdOut
     * @see AdminSession#openRegistryStdErr
     */
    class FileNotAvailableException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 55`] = `
"import { Ice } from \\"ice\\";
import { IceGrid } from \\"../IceGrid/Admin\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    /**
     * This exception is raised if an error occurs during parsing.
     */
    class ParseException extends Ice.UserException {
      constructor(reason?: string);

      reason: string;
    }

    /**
     * <tt>icegridadmin</tt> provides a {@link FileParser}
     * object to transform XML files into {@link ApplicationDescriptor}
     * objects.
     */
    abstract class FileParser extends Ice.Object {
      /**
       * Parse a file.
       *
       * @param xmlFile Full pathname to the file.
       *
       * @param adminProxy An Admin proxy, used only to retrieve default
       * templates when needed. May be null.
       *
       * @return The application descriptor.
       *
       * @throws ParseException Raised if an error occurred during parsing.
       */
      abstract parse(
        xmlFile: string,
        adminProxy: AdminPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<ApplicationDescriptor>;
    }

    /**
     * <tt>icegridadmin</tt> provides a {@link FileParser}
     * object to transform XML files into {@link ApplicationDescriptor}
     * objects.
     */
    class FileParserPrx extends Ice.ObjectPrx {
      /**
       * Parse a file.
       *
       * @param xmlFile Full pathname to the file.
       *
       * @param adminProxy An Admin proxy, used only to retrieve default
       * templates when needed. May be null.
       *
       * @return The application descriptor.
       *
       * @throws ParseException Raised if an error occurred during parsing.
       */
      parse(
        xmlFile: string,
        adminProxy: AdminPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<ApplicationDescriptor>;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 56`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";
import \\"../Ice/Current\\";
import { IceGrid } from \\"../IceGrid/Admin\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    /**
     * The ReplicaGroupFilter is used by IceGrid to filter adapters
     * returned to the client when it resolves a filtered replica group.
     *
     * IceGrid provides the list of available adapters. The implementation
     * of this method can use the provided context and connection to
     * filter and return the filtered set of adapters.
     */
    interface ReplicaGroupFilter {
      /**
       * Filter the the given set of adapters.
       *
       * @param replicaGroupId The replica group ID.
       *
       * @param adapterIds The adpater IDs to filter.
       *
       * @param con The connection from the Ice client which is
       * resolving the replica group endpoints.
       *
       * @param ctx The context from the Ice client which is resolving
       * the replica group endpoints.
       *
       * @return The filtered adapter IDs.
       */
      filter(
        replicaGroupId: string,
        adapterIds: Ice.StringSeq,
        con: Ice.Connection,
        ctx: Ice.Context
      ): Ice.StringSeq;
    }

    /**
     * The TypeFilter is used by IceGrid to filter well-known proxies
     * returned to the client when it searches a well-known object by
     * type.
     *
     * IceGrid provides the list of available proxies. The implementation
     * of this method can use the provided context and connection to
     * filter and return the filtered set of proxies.
     */
    interface TypeFilter {
      /**
       * Filter the the given set of proxies.
       *
       * @param type The type.
       *
       * @param proxies The proxies to filter.
       *
       * @param con The connection from the Ice client which is
       * looking up well-known objects by type.
       *
       * @param ctx The context from the Ice client which is looking up
       * well-known objects by type.
       *
       * @return The filtered proxies.
       */
      filter(
        type: string,
        proxies: Ice.ObjectProxySeq,
        con: Ice.Connection,
        ctx: Ice.Context
      ): Ice.ObjectProxySeq;
    }

    /**
     * The RegistryPluginFacade is implemented by IceGrid and can be used
     * by plugins and filter implementations to retrieve information from
     * IceGrid about the well-known objects or adapters. It's also used to
     * register/unregister replica group and type filters.
     */
    interface RegistryPluginFacade {
      /**
       * Get an application descriptor.
       *
       * @param name The application name.
       *
       * @return The application descriptor.
       *
       * @throws ApplicationNotExistException Raised if the application
       * doesn't exist.
       */
      getApplicationInfo(name: string): ApplicationInfo;

      /**
       * Get the server information for the server with the given id.
       *
       * @param id The server id.
       *
       * @throws ServerNotExistException Raised if the server doesn't exist.
       *
       * @return The server information.
       */
      getServerInfo(id: string): ServerInfo;

      /**
       * Get the ID of the server to which the given adapter belongs.
       *
       * @param adapterId The adapter ID.
       *
       * @return The server ID or the empty string if the given
       * identifier is not associated to an object adapter defined with
       * an application descriptor.
       *
       * @throws AdapterNotExistException Raised if the adapter doesn't
       * exist.
       */
      getAdapterServer(adapterId: string): string;

      /**
       * Get the name of the application to which the given adapter belongs.
       *
       * @param adapterId The adapter ID.
       *
       * @return The application name or the empty string if the given
       * identifier is not associated to a replica group or object
       * adapter defined with an application descriptor.
       *
       * @throws AdapterNotExistException Raised if the adapter doesn't
       * exist.
       */
      getAdapterApplication(adapterId: string): string;

      /**
       * Get the name of the node to which the given adapter belongs.
       *
       * @param adapterId The adapter ID.
       *
       * @return The node name or the empty string if the given
       * identifier is not associated to an object adapter defined with
       * an application descriptor.
       *
       * @throws AdapterNotExistException Raised if the adapter doesn't
       * exist.
       */
      getAdapterNode(adapterId: string): string;

      /**
       * Get the adapter information for the replica group or adapter
       * with the given id.
       *
       * @param id The adapter id.
       *
       * @return A sequence of adapter information structures. If the
       * given id refers to an adapter, this sequence will contain only
       * one element. If the given id refers to a replica group, the
       * sequence will contain the adapter information of each member of
       * the replica group.
       *
       * @throws AdapterNotExistException Raised if the adapter or
       * replica group doesn't exist.
       */
      getAdapterInfo(id: string): AdapterInfoSeq;

      /**
       * Get the object info for the object with the given identity.
       *
       * @param id The identity of the object.
       *
       * @return The object info.
       *
       * @throws ObjectNotRegisteredException Raised if the object isn't
       * registered with the registry.
       */
      getObjectInfo(id: Ice.Identity): ObjectInfo;

      /**
       * Get the node information for the node with the given name.
       *
       * @param name The node name.
       *
       * @return The node information.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      getNodeInfo(name: string): NodeInfo;

      /**
       * Get the load averages of the node.
       *
       * @param name The node name.
       *
       * @return The node load information.
       *
       * @throws NodeNotExistException Raised if the node doesn't exist.
       *
       * @throws NodeUnreachableException Raised if the node could not be
       * reached.
       */
      getNodeLoad(name: string): LoadInfo;

      /**
       * Get the property value for the given property and adapter. The
       * property is looked up in the server or service descriptor where
       * the adapter is defined.
       *
       * @param adapterId The adapter ID
       *
       * @param name The name of the property.
       *
       * @return The property value.
       *
       * @throws AdapterNotExistException Raised if the adapter doesn't exist.
       */
      getPropertyForAdapter(adapterId: string, name: string): string;

      /**
       * Add a replica group filter.
       *
       * @param id The identifier of the filter. This identifier must
       * match the value of the \\"filter\\" attribute specified in the
       * replica group descriptor. To filter dynamically registered
       * replica groups, you should use the empty filter id.
       *
       * @param filter The filter implementation.
       */
      addReplicaGroupFilter(id: string, filter: ReplicaGroupFilter): void;

      /**
       * Remove a replica group filter.
       *
       * @param id The identifier of the filter.
       *
       * @param filter The filter implementation.
       *
       * @return True of the filter was removed, false otherwise.
       */
      removeReplicaGroupFilter(id: string, filter: ReplicaGroupFilter): boolean;

      /**
       * Add a type filter.
       *
       * @param type The type to register this filter with.
       *
       * @param filter The filter implementation.
       */
      addTypeFilter(type: string, filter: TypeFilter): void;

      /**
       * Remove a type filter.
       *
       * @param type The type to register this filter with.
       *
       * @param filter The filter implementation.
       *
       * @return True of the filter was removed, false otherwise.
       */
      removeTypeFilter(type: string, filter: TypeFilter): boolean;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 57`] = `
"import { Ice } from \\"ice\\";
import { IceGrid } from \\"../IceGrid/Exception\\";
import \\"../IceGrid/Session\\";
import \\"../IceGrid/Admin\\";
import \\"../Ice/Locator\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    type LoadSampleName = \\"LoadSample1\\" | \\"LoadSample5\\" | \\"LoadSample15\\";

    /**
     * Determines which load sampling interval to use.
     */
    class LoadSample<
      Name extends LoadSampleName = LoadSampleName
    > extends Ice.EnumBase<Name> {
      /**
       * Sample every minute.
       */
      static LoadSample1: LoadSample<\\"LoadSample1\\">;

      /**
       * Sample every five minutes.
       */
      static LoadSample5: LoadSample<\\"LoadSample5\\">;

      /**
       * Sample every fifteen minutes.
       */
      static LoadSample15: LoadSample<\\"LoadSample15\\">;
    }

    /**
     * The IceGrid query interface. This interface is accessible to
     * Ice clients who wish to look up well-known objects.
     */
    abstract class Query extends Ice.Object {
      /**
       * Find a well-known object by identity.
       *
       * @param id The identity.
       *
       * @return The proxy or null if no such object has been found.
       */
      abstract findObjectById(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Find a well-known object by type. If there are several objects
       * registered for the given type, the object is randomly
       * selected.
       *
       * @param type The object type.
       *
       * @return The proxy or null, if no such object has been found.
       */
      abstract findObjectByType(
        type: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Find a well-known object by type on the least-loaded node. If
       * the registry does not know which node hosts the object
       * (for example, because the object was registered with a direct proxy), the
       * registry assumes the object is hosted on a node that has a load
       * average of 1.0.
       *
       * @param type The object type.
       *
       * @param sample The sampling interval.
       *
       * @return The proxy or null, if no such object has been found.
       */
      abstract findObjectByTypeOnLeastLoadedNode(
        type: string,
        sample: LoadSample,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Find all the well-known objects with the given type.
       *
       * @param type The object type.
       *
       * @return The proxies or an empty sequence, if no such objects
       * have been found.
       */
      abstract findAllObjectsByType(
        type: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectProxySeq>;

      /**
       * Find all the object replicas associated with the given
       * proxy. If the given proxy is not an indirect proxy from a
       * replica group, an empty sequence is returned.
       *
       * @param proxy The object proxy.
       *
       * @return The proxies of each object replica or an empty sequence,
       * if the given proxy is not from a replica group.
       */
      abstract findAllReplicas(
        proxy: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectProxySeq>;
    }

    /**
     * The IceGrid query interface. This interface is accessible to
     * Ice clients who wish to look up well-known objects.
     */
    class QueryPrx extends Ice.ObjectPrx {
      /**
       * Find a well-known object by identity.
       *
       * @param id The identity.
       *
       * @return The proxy or null if no such object has been found.
       */
      findObjectById(
        id: Ice.Identity,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Find a well-known object by type. If there are several objects
       * registered for the given type, the object is randomly
       * selected.
       *
       * @param type The object type.
       *
       * @return The proxy or null, if no such object has been found.
       */
      findObjectByType(
        type: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Find a well-known object by type on the least-loaded node. If
       * the registry does not know which node hosts the object
       * (for example, because the object was registered with a direct proxy), the
       * registry assumes the object is hosted on a node that has a load
       * average of 1.0.
       *
       * @param type The object type.
       *
       * @param sample The sampling interval.
       *
       * @return The proxy or null, if no such object has been found.
       */
      findObjectByTypeOnLeastLoadedNode(
        type: string,
        sample: LoadSample,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Find all the well-known objects with the given type.
       *
       * @param type The object type.
       *
       * @return The proxies or an empty sequence, if no such objects
       * have been found.
       */
      findAllObjectsByType(
        type: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectProxySeq>;

      /**
       * Find all the object replicas associated with the given
       * proxy. If the given proxy is not an indirect proxy from a
       * replica group, an empty sequence is returned.
       *
       * @param proxy The object proxy.
       *
       * @return The proxies of each object replica or an empty sequence,
       * if the given proxy is not from a replica group.
       */
      findAllReplicas(
        proxy: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectProxySeq>;
    }

    /**
     * The IceGrid registry allows clients create sessions
     * directly with the registry.
     *
     * @see Session
     * @see AdminSession
     */
    abstract class Registry extends Ice.Object {
      /**
       * Create a client session.
       *
       * @return A proxy for the newly created session.
       *
       * @param userId The user id.
       *
       * @param password The password for the given user id.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      abstract createSession(
        userId: string,
        password: string,
        current: Ice.Current
      ): Ice.OperationResult<SessionPrx | null>;

      /**
       * Create an administrative session.
       *
       * @return A proxy for the newly created session.
       *
       * @param userId The user id.
       *
       * @param password The password for the given user id.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      abstract createAdminSession(
        userId: string,
        password: string,
        current: Ice.Current
      ): Ice.OperationResult<AdminSessionPrx | null>;

      /**
       * Create a client session from a secure connection.
       *
       * @return A proxy for the newly created session.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      abstract createSessionFromSecureConnection(
        current: Ice.Current
      ): Ice.OperationResult<SessionPrx | null>;

      /**
       * Create an administrative session from a secure connection.
       *
       * @return A proxy for the newly created session.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      abstract createAdminSessionFromSecureConnection(
        current: Ice.Current
      ): Ice.OperationResult<AdminSessionPrx | null>;

      /**
       * Get the session timeout. If a client or administrative client
       * doesn't call the session keepAlive method in the time interval
       * defined by this timeout, IceGrid might reap the session.
       *
       * @see Session#keepAlive
       * @see AdminSession#keepAlive
       *
       * @return The timeout (in seconds).
       */
      abstract getSessionTimeout(
        current: Ice.Current
      ): Ice.OperationResult<number>;

      /**
       * Get the value of the ACM timeout. Clients supporting ACM
       * connection heartbeats can enable them instead of explicitly
       * sending keep alives requests.
       *
       * NOTE: This method is only available since Ice 3.6.
       *
       * @return The timeout (in seconds).
       */
      abstract getACMTimeout(current: Ice.Current): Ice.OperationResult<number>;
    }

    /**
     * The IceGrid registry allows clients create sessions
     * directly with the registry.
     *
     * @see Session
     * @see AdminSession
     */
    class RegistryPrx extends Ice.ObjectPrx {
      /**
       * Create a client session.
       *
       * @return A proxy for the newly created session.
       *
       * @param userId The user id.
       *
       * @param password The password for the given user id.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      createSession(
        userId: string,
        password: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<SessionPrx | null>;

      /**
       * Create an administrative session.
       *
       * @return A proxy for the newly created session.
       *
       * @param userId The user id.
       *
       * @param password The password for the given user id.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      createAdminSession(
        userId: string,
        password: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<AdminSessionPrx | null>;

      /**
       * Create a client session from a secure connection.
       *
       * @return A proxy for the newly created session.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      createSessionFromSecureConnection(
        ctx?: Ice.Context
      ): Ice.AsyncResult<SessionPrx | null>;

      /**
       * Create an administrative session from a secure connection.
       *
       * @return A proxy for the newly created session.
       *
       * @throws PermissionDeniedException Raised if the password for
       * the given user id is not correct, or if the user is not allowed
       * access.
       */
      createAdminSessionFromSecureConnection(
        ctx?: Ice.Context
      ): Ice.AsyncResult<AdminSessionPrx | null>;

      /**
       * Get the session timeout. If a client or administrative client
       * doesn't call the session keepAlive method in the time interval
       * defined by this timeout, IceGrid might reap the session.
       *
       * @see Session#keepAlive
       * @see AdminSession#keepAlive
       *
       * @return The timeout (in seconds).
       */
      getSessionTimeout(ctx?: Ice.Context): Ice.AsyncResult<number>;

      /**
       * Get the value of the ACM timeout. Clients supporting ACM
       * connection heartbeats can enable them instead of explicitly
       * sending keep alives requests.
       *
       * NOTE: This method is only available since Ice 3.6.
       *
       * @return The timeout (in seconds).
       */
      getACMTimeout(ctx?: Ice.Context): Ice.AsyncResult<number>;
    }

    /**
     * The IceGrid locator interface provides access to the {@link Query}
     * and {@link Registry} object of the IceGrid registry.
     *
     * @see Query
     * @see Registry
     */
    abstract class Locator extends Ice.Object implements Ice.Locator {
      /**
       * Find an object by identity and return a proxy that contains
       * the adapter ID or endpoints which can be used to access the
       * object.
       *
       * @param id The identity.
       *
       * @return The proxy, or null if the object is not active.
       *
       * @throws ObjectNotFoundException Raised if the object cannot
       * be found.
       */
      abstract findObjectById(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Find an adapter by id and return a proxy that contains
       * its endpoints.
       *
       * @param id The adapter id.
       *
       * @return The adapter proxy, or null if the adapter is not active.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot be
       * found.
       */
      abstract findAdapterById(
        id: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Get the locator registry.
       *
       * @return The locator registry.
       */
      abstract getRegistry(
        current: Ice.Current
      ): Ice.OperationResult<Ice.LocatorRegistryPrx | null>;

      /**
       * Get the proxy of the registry object hosted by this IceGrid
       * registry.
       *
       * @return The proxy of the registry object.
       */
      abstract getLocalRegistry(
        current: Ice.Current
      ): Ice.OperationResult<RegistryPrx | null>;

      /**
       * Get the proxy of the query object hosted by this IceGrid
       * registry.
       *
       * @return The proxy of the query object.
       */
      abstract getLocalQuery(
        current: Ice.Current
      ): Ice.OperationResult<QueryPrx | null>;
    }

    /**
     * The IceGrid locator interface provides access to the {@link Query}
     * and {@link Registry} object of the IceGrid registry.
     *
     * @see Query
     * @see Registry
     */
    class LocatorPrx extends Ice.ObjectPrx implements Ice.LocatorPrx {
      /**
       * Find an object by identity and return a proxy that contains
       * the adapter ID or endpoints which can be used to access the
       * object.
       *
       * @param id The identity.
       *
       * @return The proxy, or null if the object is not active.
       *
       * @throws ObjectNotFoundException Raised if the object cannot
       * be found.
       */
      findObjectById(
        id: Ice.Identity,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Find an adapter by id and return a proxy that contains
       * its endpoints.
       *
       * @param id The adapter id.
       *
       * @return The adapter proxy, or null if the adapter is not active.
       *
       * @throws AdapterNotFoundException Raised if the adapter cannot be
       * found.
       */
      findAdapterById(
        id: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Get the locator registry.
       *
       * @return The locator registry.
       */
      getRegistry(
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.LocatorRegistryPrx | null>;

      /**
       * Get the proxy of the registry object hosted by this IceGrid
       * registry.
       *
       * @return The proxy of the registry object.
       */
      getLocalRegistry(ctx?: Ice.Context): Ice.AsyncResult<RegistryPrx | null>;

      /**
       * Get the proxy of the query object hosted by this IceGrid
       * registry.
       *
       * @return The proxy of the query object.
       */
      getLocalQuery(ctx?: Ice.Context): Ice.AsyncResult<QueryPrx | null>;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 58`] = `
"import { Ice } from \\"ice\\";
import { Glacier2 } from \\"../Glacier2/Session\\";
import { IceGrid } from \\"../IceGrid/Exception\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    /**
     * A session object is used by IceGrid clients to allocate and
     * release objects. Client sessions are created either via the
     * {@link Registry} object or via the registry client <tt>SessionManager</tt>
     * object.
     *
     * @see Registry
     */
    abstract class Session extends Ice.Object implements Glacier2.Session {
      /**
       * Destroy the session. This is called automatically when the router is destroyed.
       */
      abstract destroy(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Keep the session alive. Clients should call this operation
       * regularly to prevent the server from reaping the session.
       *
       * @see Registry#getSessionTimeout
       */
      abstract keepAlive(current: Ice.Current): Ice.OperationResult<void>;

      /**
       * Allocate an object. Depending on the allocation timeout, this
       * operation might hang until the object is available or until the
       * timeout is reached.
       *
       * @param id The identity of the object to allocate.
       *
       * @return The proxy of the allocated object.
       *
       * @throws ObjectNotRegisteredException Raised if the object with
       * the given identity is not registered with the registry.
       *
       * @throws AllocationException Raised if the object can't be
       * allocated.
       *
       * @see #setAllocationTimeout
       * @see #releaseObject
       */
      abstract allocateObjectById(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Allocate an object with the given type. Depending on the
       * allocation timeout, this operation can block until an object
       * becomes available or until the timeout is reached.
       *
       * @param type The type of the object.
       *
       * @return The proxy of the allocated object.
       *
       * @throws AllocationException Raised if the object could not be allocated.
       *
       * @see #setAllocationTimeout
       * @see #releaseObject
       */
      abstract allocateObjectByType(
        type: string,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Release an object that was allocated using <tt>allocateObjectById</tt> or
       * <tt>allocateObjectByType</tt>.
       *
       * @param id The identity of the object to release.
       *
       * @throws ObjectNotRegisteredException Raised if the object with
       * the given identity is not registered with the registry.
       *
       * @throws AllocationException Raised if the given object can't be
       * released. This might happen if the object isn't allocatable or
       * isn't allocated by the session.
       */
      abstract releaseObject(
        id: Ice.Identity,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Set the allocation timeout. If no objects are available for an
       * allocation request, a call to <tt>allocateObjectById</tt> or
       * <tt>allocateObjectByType</tt> will block for the duration of this
       * timeout.
       *
       * @param timeout The timeout in milliseconds.
       */
      abstract setAllocationTimeout(
        timeout: number,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * A session object is used by IceGrid clients to allocate and
     * release objects. Client sessions are created either via the
     * {@link Registry} object or via the registry client <tt>SessionManager</tt>
     * object.
     *
     * @see Registry
     */
    class SessionPrx extends Ice.ObjectPrx implements Glacier2.SessionPrx {
      /**
       * Destroy the session. This is called automatically when the router is destroyed.
       */
      destroy(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Keep the session alive. Clients should call this operation
       * regularly to prevent the server from reaping the session.
       *
       * @see Registry#getSessionTimeout
       */
      keepAlive(ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Allocate an object. Depending on the allocation timeout, this
       * operation might hang until the object is available or until the
       * timeout is reached.
       *
       * @param id The identity of the object to allocate.
       *
       * @return The proxy of the allocated object.
       *
       * @throws ObjectNotRegisteredException Raised if the object with
       * the given identity is not registered with the registry.
       *
       * @throws AllocationException Raised if the object can't be
       * allocated.
       *
       * @see #setAllocationTimeout
       * @see #releaseObject
       */
      allocateObjectById(
        id: Ice.Identity,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Allocate an object with the given type. Depending on the
       * allocation timeout, this operation can block until an object
       * becomes available or until the timeout is reached.
       *
       * @param type The type of the object.
       *
       * @return The proxy of the allocated object.
       *
       * @throws AllocationException Raised if the object could not be allocated.
       *
       * @see #setAllocationTimeout
       * @see #releaseObject
       */
      allocateObjectByType(
        type: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Release an object that was allocated using <tt>allocateObjectById</tt> or
       * <tt>allocateObjectByType</tt>.
       *
       * @param id The identity of the object to release.
       *
       * @throws ObjectNotRegisteredException Raised if the object with
       * the given identity is not registered with the registry.
       *
       * @throws AllocationException Raised if the given object can't be
       * released. This might happen if the object isn't allocatable or
       * isn't allocated by the session.
       */
      releaseObject(id: Ice.Identity, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Set the allocation timeout. If no objects are available for an
       * allocation request, a call to <tt>allocateObjectById</tt> or
       * <tt>allocateObjectByType</tt> will block for the duration of this
       * timeout.
       *
       * @param timeout The timeout in milliseconds.
       */
      setAllocationTimeout(
        timeout: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 59`] = `
"import { Ice } from \\"ice\\";

declare module \\"./IceGrid.ns\\" {
  namespace IceGrid {
    /**
     * This exception is raised if a user account for a given session
     * identifier can't be found.
     */
    class UserAccountNotFoundException extends Ice.UserException {}

    /**
     * A user account mapper object is used by IceGrid nodes to map
     * session identifiers to user accounts.
     */
    abstract class UserAccountMapper extends Ice.Object {
      /**
       * Get the name of the user account for the given user. This is
       * used by IceGrid nodes to figure out the user account to use
       * to run servers.
       *
       * @param user The value of the server descriptor's <tt>user</tt>
       * attribute. If this attribute is not defined, and the server's
       * activation mode is <tt>session</tt>, the default value of
       * <tt>user</tt> is the session identifier.
       *
       * @return The user account name.
       *
       * @throws UserAccountNotFoundException Raised if no user account
       * is found for the given user.
       */
      abstract getUserAccount(
        user: string,
        current: Ice.Current
      ): Ice.OperationResult<string>;
    }

    /**
     * A user account mapper object is used by IceGrid nodes to map
     * session identifiers to user accounts.
     */
    class UserAccountMapperPrx extends Ice.ObjectPrx {
      /**
       * Get the name of the user account for the given user. This is
       * used by IceGrid nodes to figure out the user account to use
       * to run servers.
       *
       * @param user The value of the server descriptor's <tt>user</tt>
       * attribute. If this attribute is not defined, and the server's
       * activation mode is <tt>session</tt>, the default value of
       * <tt>user</tt> is the session identifier.
       *
       * @return The user account name.
       *
       * @throws UserAccountNotFoundException Raised if no user account
       * is found for the given user.
       */
      getUserAccount(user: string, ctx?: Ice.Context): Ice.AsyncResult<string>;
    }
  }
}
export { IceGrid } from \\"./IceGrid.ns\\";
"
`;

exports[`generate typings built-in slices 60`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Connection\\";

declare module \\"./IceIAP.ns\\" {
  namespace IceIAP {
    /**
     * Provides access to the connection details of an IAP connection
     */
    class ConnectionInfo extends Ice.ConnectionInfo {
      constructor(
        underlying?: Ice.ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string,
        name?: string,
        manufacturer?: string,
        modelNumber?: string,
        firmwareRevision?: string,
        hardwareRevision?: string,
        protocol?: string
      );

      /**
       * The accessory name.
       */
      name: string;

      /**
       * The accessory manufacturer.
       */
      manufacturer: string;

      /**
       * The accessory model number.
       */
      modelNumber: string;

      /**
       * The accessory firmare revision.
       */
      firmwareRevision: string;

      /**
       * The accessory hardware revision.
       */
      hardwareRevision: string;

      /**
       * The protocol used by the accessory.
       */
      protocol: string;
    }
  }
}
export { IceIAP } from \\"./IceIAP.ns\\";
"
`;

exports[`generate typings built-in slices 61`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Endpoint\\";

declare module \\"./IceIAP.ns\\" {
  /**
   * IceIAP provides a secure transport for Ice.
   */
  namespace IceIAP {
    /**
     * Provides access to an IAP endpoint information.
     */
    class EndpointInfo extends Ice.EndpointInfo {
      constructor(
        underlying?: Ice.EndpointInfo | null,
        timeout?: number,
        compress?: boolean,
        manufacturer?: string,
        modelNumber?: string,
        name?: string,
        protocol?: string
      );

      /**
       * The accessory manufacturer or empty to not match against
       * a manufacturer.
       */
      manufacturer: string;

      /**
       * The accessory model number or empty to not match against
       * a model number.
       */
      modelNumber: string;

      /**
       * The accessory name or empty to not match against
       * the accessory name.
       */
      name: string;

      /**
       * The protocol supported by the accessory.
       */
      protocol: string;
    }
  }
}
export { IceIAP } from \\"./IceIAP.ns\\";
"
`;

exports[`generate typings built-in slices 62`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Locator\\";

declare module \\"./IceLocatorDiscovery.ns\\" {
  /**
   * IceLocatorDiscovery is an Ice plug-in that enables the discovery of IceGrid and custom locators via
   * UDP multicast.
   */
  namespace IceLocatorDiscovery {
    /**
     * The Ice lookup reply interface must be implemented by clients which
     * are searching for Ice locators. Ice locator implementations invoke
     * on this interface to provide their locator proxy.
     *
     * @see Lookup
     */
    abstract class LookupReply extends Ice.Object {
      /**
       * This method is called by the implementation of the Lookup
       * interface to reply to a findLocator request.
       *
       * @param prx The proxy of the locator.
       */
      abstract foundLocator(
        prx: Ice.LocatorPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * The Ice lookup reply interface must be implemented by clients which
     * are searching for Ice locators. Ice locator implementations invoke
     * on this interface to provide their locator proxy.
     *
     * @see Lookup
     */
    class LookupReplyPrx extends Ice.ObjectPrx {
      /**
       * This method is called by the implementation of the Lookup
       * interface to reply to a findLocator request.
       *
       * @param prx The proxy of the locator.
       */
      foundLocator(
        prx: Ice.LocatorPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }

    /**
     * The Ice lookup interface is implemented by Ice locator
     * implementations and can be used by clients to find available Ice
     * locators on the network.
     *
     * Ice locator implementations provide a well-known \`Ice/LocatorLookup'
     * object accessible through UDP multicast. Clients typically make a
     * multicast findLocator request to find the locator proxy.
     *
     * @see LookupReply
     */
    abstract class Lookup extends Ice.Object {
      /**
       * Find a locator proxy with the given instance name.
       *
       * @param instanceName Restrict the search to Ice registries
       * configured with the given instance name. If empty, all the
       * available registries will reply.
       *
       * @param reply The reply object to use to send the reply.
       */
      abstract findLocator(
        instanceName: string,
        reply: LookupReplyPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;
    }

    /**
     * The Ice lookup interface is implemented by Ice locator
     * implementations and can be used by clients to find available Ice
     * locators on the network.
     *
     * Ice locator implementations provide a well-known \`Ice/LocatorLookup'
     * object accessible through UDP multicast. Clients typically make a
     * multicast findLocator request to find the locator proxy.
     *
     * @see LookupReply
     */
    class LookupPrx extends Ice.ObjectPrx {
      /**
       * Find a locator proxy with the given instance name.
       *
       * @param instanceName Restrict the search to Ice registries
       * configured with the given instance name. If empty, all the
       * available registries will reply.
       *
       * @param reply The reply object to use to send the reply.
       */
      findLocator(
        instanceName: string,
        reply: LookupReplyPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;
    }
  }
}
export { IceLocatorDiscovery } from \\"./IceLocatorDiscovery.ns\\";
"
`;

exports[`generate typings built-in slices 63`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/BuiltinSequences\\";

declare module \\"./IcePatch2.ns\\" {
  namespace IcePatch2 {
    /**
     * Basic information about a single file.
     */
    class FileInfo implements Ice.Struct {
      constructor(
        path?: string,
        checksum?: Ice.ByteSeq,
        size?: number,
        executable?: boolean
      );

      path: string;
      checksum: Ice.ByteSeq;
      size: number;
      executable: boolean;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence with information about many files.
     */
    type FileInfoSeq = Array<FileInfo>;

    /**
     * Basic information about a single file.
     */
    class LargeFileInfo implements Ice.Struct {
      constructor(
        path?: string,
        checksum?: Ice.ByteSeq,
        size?: Ice.Long,
        executable?: boolean
      );

      path: string;
      checksum: Ice.ByteSeq;
      size: Ice.Long;
      executable: boolean;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence with information about many files.
     */
    type LargeFileInfoSeq = Array<LargeFileInfo>;
  }
}
export { IcePatch2 } from \\"./IcePatch2.ns\\";
"
`;

exports[`generate typings built-in slices 64`] = `
"import { Ice } from \\"ice\\";
import { IcePatch2 } from \\"../IcePatch2/FileInfo\\";

declare module \\"./IcePatch2.ns\\" {
  /**
   * IcePatch can be used to update file hierarchies in a simple and
   * efficient manner. Checksums ensure file integrity, and data is
   * compressed before downloading.
   */
  namespace IcePatch2 {
    /**
     * A sequence of byte sequences. Each element is the checksum for a
     * partition.
     */
    type ByteSeqSeq = Array<Ice.ByteSeq>;

    /**
     * A <tt>partition</tt> argument was not in the range 0-255.
     */
    class PartitionOutOfRangeException extends Ice.UserException {}

    /**
     * This exception is raised if a file's contents cannot be read.
     */
    class FileAccessException extends Ice.UserException {
      constructor(reason?: string);

      /**
       * An explanation of the reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception is raised if an operation tries to use a file whose size is
     * larger than 2.1 GB. Use the \\"large\\" versions of the operations instead.
     */
    class FileSizeRangeException extends FileAccessException {}

    /**
     * The interface that provides access to files.
     */
    abstract class FileServer extends Ice.Object {
      /**
       * Return file information for the specified partition.
       *
       * <p class=\\"Deprecated\\"> This operation is deprecated and only present for
       * compatibility with old Ice clients (older than version 3.6).
       *
       * @param partition The partition number in the range 0-255.
       *
       * @return A sequence containing information about the files in the
       * specified partition.
       *
       * @throws PartitionOutOfRangeException If the partition number is out of range.
       * @throws FileSizeRangeException If a file is larger than 2.1GB.
       */
      abstract getFileInfoSeq(
        partition: number,
        current: Ice.Current
      ): Ice.OperationResult<FileInfoSeq>;

      /**
       * Returns file information for the specified partition.
       *
       * @param partition The partition number in the range 0-255.
       *
       * @return A sequence containing information about the files in the
       * specified partition.
       *
       * @throws PartitionOutOfRangeException If the partition number is out of range.
       */
      abstract getLargeFileInfoSeq(
        partition: number,
        current: Ice.Current
      ): Ice.OperationResult<LargeFileInfoSeq>;

      /**
       * Return the checksums for all partitions.
       *
       * @return A sequence containing 256 checksums. Partitions with a
       * checksum that differs from the previous checksum for the same
       * partition contain updated files. Partitions with a checksum
       * that is identical to the previous checksum do not contain
       * updated files.
       */
      abstract getChecksumSeq(
        current: Ice.Current
      ): Ice.OperationResult<ByteSeqSeq>;

      /**
       * Return the master checksum for all partitions. If this checksum is the same
       * as for a previous run, the entire file set is up-to-date.
       *
       * @return The master checksum for the file set.
       */
      abstract getChecksum(
        current: Ice.Current
      ): Ice.OperationResult<Ice.ByteSeq>;

      /**
       * Read the specified file. This operation may only return fewer bytes than requested
       * in case there was an end-of-file condition.
       *
       * <p class=\\"Deprecated\\"> This operation is deprecated and only present for
       * compatibility with old Ice clients (older than version 3.6).
       *
       * @param path The pathname (relative to the data directory) for
       * the file to be read.
       *
       * @param pos The file offset at which to begin reading.
       *
       * @param num The number of bytes to be read.
       *
       * @return A sequence containing the compressed file contents.
       *
       * @throws FileAccessException If an error occurred while trying to read the file.
       * @throws FileSizeRangeException If a file is larger than 2.1GB.
       */
      abstract getFileCompressed(
        path: string,
        pos: number,
        num: number,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ByteSeq>;

      /**
       * Read the specified file. This operation may only return fewer bytes than requested
       * in case there was an end-of-file condition.
       *
       * @param path The pathname (relative to the data directory) for
       * the file to be read.
       *
       * @param pos The file offset at which to begin reading.
       *
       * @param num The number of bytes to be read.
       *
       * @return A sequence containing the compressed file contents.
       *
       * @throws FileAccessException If an error occurred while trying to read the file.
       */
      abstract getLargeFileCompressed(
        path: string,
        pos: Ice.Long,
        num: number,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ByteSeq>;
    }

    /**
     * The interface that provides access to files.
     */
    class FileServerPrx extends Ice.ObjectPrx {
      /**
       * Return file information for the specified partition.
       *
       * <p class=\\"Deprecated\\"> This operation is deprecated and only present for
       * compatibility with old Ice clients (older than version 3.6).
       *
       * @param partition The partition number in the range 0-255.
       *
       * @return A sequence containing information about the files in the
       * specified partition.
       *
       * @throws PartitionOutOfRangeException If the partition number is out of range.
       * @throws FileSizeRangeException If a file is larger than 2.1GB.
       */
      getFileInfoSeq(
        partition: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<FileInfoSeq>;

      /**
       * Returns file information for the specified partition.
       *
       * @param partition The partition number in the range 0-255.
       *
       * @return A sequence containing information about the files in the
       * specified partition.
       *
       * @throws PartitionOutOfRangeException If the partition number is out of range.
       */
      getLargeFileInfoSeq(
        partition: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<LargeFileInfoSeq>;

      /**
       * Return the checksums for all partitions.
       *
       * @return A sequence containing 256 checksums. Partitions with a
       * checksum that differs from the previous checksum for the same
       * partition contain updated files. Partitions with a checksum
       * that is identical to the previous checksum do not contain
       * updated files.
       */
      getChecksumSeq(ctx?: Ice.Context): Ice.AsyncResult<ByteSeqSeq>;

      /**
       * Return the master checksum for all partitions. If this checksum is the same
       * as for a previous run, the entire file set is up-to-date.
       *
       * @return The master checksum for the file set.
       */
      getChecksum(ctx?: Ice.Context): Ice.AsyncResult<Ice.ByteSeq>;

      /**
       * Read the specified file. This operation may only return fewer bytes than requested
       * in case there was an end-of-file condition.
       *
       * <p class=\\"Deprecated\\"> This operation is deprecated and only present for
       * compatibility with old Ice clients (older than version 3.6).
       *
       * @param path The pathname (relative to the data directory) for
       * the file to be read.
       *
       * @param pos The file offset at which to begin reading.
       *
       * @param num The number of bytes to be read.
       *
       * @return A sequence containing the compressed file contents.
       *
       * @throws FileAccessException If an error occurred while trying to read the file.
       * @throws FileSizeRangeException If a file is larger than 2.1GB.
       */
      getFileCompressed(
        path: string,
        pos: number,
        num: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ByteSeq>;

      /**
       * Read the specified file. This operation may only return fewer bytes than requested
       * in case there was an end-of-file condition.
       *
       * @param path The pathname (relative to the data directory) for
       * the file to be read.
       *
       * @param pos The file offset at which to begin reading.
       *
       * @param num The number of bytes to be read.
       *
       * @return A sequence containing the compressed file contents.
       *
       * @throws FileAccessException If an error occurred while trying to read the file.
       */
      getLargeFileCompressed(
        path: string,
        pos: Ice.Long,
        num: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ByteSeq>;
    }
  }
}
export { IcePatch2 } from \\"./IcePatch2.ns\\";
"
`;

exports[`generate typings built-in slices 65`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Connection\\";

declare module \\"./IceSSL.ns\\" {
  namespace IceSSL {
    /**
     * Provides access to the connection details of an SSL connection
     */
    class ConnectionInfo extends Ice.ConnectionInfo {
      constructor(
        underlying?: Ice.ConnectionInfo | null,
        incoming?: boolean,
        adapterName?: string,
        connectionId?: string,
        cipher?: string,
        certs?: Ice.StringSeq,
        verified?: boolean
      );

      cipher: string;
      certs: Ice.StringSeq;
      verified: boolean;
    }
  }
}
export { IceSSL } from \\"./IceSSL.ns\\";
"
`;

exports[`generate typings built-in slices 66`] = `
"import { Ice } from \\"ice\\";

declare module \\"./IceSSL.ns\\" {
  namespace IceSSL {  }
}
export { IceSSL } from \\"./IceSSL.ns\\";
"
`;

exports[`generate typings built-in slices 67`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Endpoint\\";

declare module \\"./IceSSL.ns\\" {
  namespace IceSSL {
    /**
     * Provides access to an SSL endpoint information.
     */
    class EndpointInfo extends Ice.EndpointInfo {}
  }
}
export { IceSSL } from \\"./IceSSL.ns\\";
"
`;

exports[`generate typings built-in slices 68`] = `
"import { Ice } from \\"ice\\";
import \\"../Ice/Identity\\";
import \\"../Ice/SliceChecksumDict\\";
import { IceMX } from \\"../IceStorm/Metrics\\";

declare module \\"./IceStorm.ns\\" {
  /**
   * A messaging service with support for federation. In contrast to
   * most other messaging or event services, IceStorm supports typed
   * events, meaning that broadcasting a message over a federation is as
   * easy as invoking a method on an interface.
   */
  namespace IceStorm {
    /**
     * Information on the topic links.
     */
    class LinkInfo implements Ice.Struct {
      constructor(theTopic?: TopicPrx | null, name?: string, cost?: number);

      /**
       * The linked topic.
       */
      theTopic: TopicPrx | null;

      /**
       * The name of the linked topic.
       */
      name: string;

      /**
       * The cost of traversing this link.
       */
      cost: number;

      clone(): this;
      equals(other: this): boolean;
      hashCode(): number;
    }

    /**
     * A sequence of {@link LinkInfo} objects.
     */
    type LinkInfoSeq = Array<LinkInfo>;

    type QoS = Map<string, string>;

    /**
     * This exception indicates that an attempt was made to create a link
     * that already exists.
     */
    class LinkExists extends Ice.UserException {
      constructor(name?: string);

      name: string;
    }

    /**
     * This exception indicates that an attempt was made to remove a
     * link that does not exist.
     */
    class NoSuchLink extends Ice.UserException {
      constructor(name?: string);

      name: string;
    }

    /**
     * This exception indicates that an attempt was made to subscribe
     * a proxy for which a subscription already exists.
     */
    class AlreadySubscribed extends Ice.UserException {}

    /**
     * This exception indicates that an attempt was made to subscribe
     * a proxy that is null.
     */
    class InvalidSubscriber extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * This exception indicates that a subscription failed due to an
     * invalid QoS.
     */
    class BadQoS extends Ice.UserException {
      constructor(reason?: string);

      /**
       * The reason for the failure.
       */
      reason: string;
    }

    /**
     * Publishers publish information on a particular topic. A topic
     * logically represents a type.
     *
     * @see TopicManager
     */
    abstract class Topic extends Ice.Object {
      /**
       * Get the name of this topic.
       *
       * @return The name of the topic.
       *
       * @see TopicManager#create
       */
      abstract getName(current: Ice.Current): Ice.OperationResult<string>;

      /**
       * Get a proxy to a publisher object for this topic. To publish
       * data to a topic, the publisher calls {@link Topic#getPublisher} and then
       * casts to the topic type. An unchecked cast must be used on this
       * proxy. If a replicated IceStorm deployment is used this call
       * may return a replicated proxy.
       *
       * @return A proxy to publish data on this topic.
       */
      abstract getPublisher(
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Get a non-replicated proxy to a publisher object for this
       * topic. To publish data to a topic, the publisher calls
       * {@link Topic#getPublisher} and then casts to the topic type. An unchecked
       * cast must be used on this proxy.
       *
       * @return A proxy to publish data on this topic.
       */
      abstract getNonReplicatedPublisher(
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Subscribe with the given <tt>qos</tt> to this topic.  A
       * per-subscriber publisher object is returned.
       *
       * @param theQoS The quality of service parameters for this
       * subscription.
       *
       * @param subscriber The subscriber's proxy.
       *
       * @return The per-subscriber publisher object.
       *
       * @throws AlreadySubscribed Raised if the subscriber object is
       * already subscribed.
       *
       * @throws InvalidSubscriber Raised if the subscriber object is null.
       *
       * @throws BadQoS Raised if the requested quality of service
       * is unavailable or invalid.
       *
       * @see #unsubscribe
       */
      abstract subscribeAndGetPublisher(
        theQoS: QoS,
        subscriber: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<Ice.ObjectPrx | null>;

      /**
       * Unsubscribe the given <tt>subscriber</tt>.
       *
       * @param subscriber The proxy of an existing subscriber.
       *
       * @see #subscribeAndGetPublisher
       */
      abstract unsubscribe(
        subscriber: Ice.ObjectPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Create a link to the given topic. All events originating
       * on this topic will also be sent to <tt>linkTo</tt>.
       *
       * @param linkTo The topic to link to.
       *
       * @param cost The cost to the linked topic.
       *
       * @throws LinkExists Raised if a link to the same topic already
       * exists.
       */
      abstract link(
        linkTo: TopicPrx | null,
        cost: number,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Destroy the link from this topic to the given topic <tt>linkTo</tt>.
       *
       * @param linkTo The topic to destroy the link to.
       *
       * @throws NoSuchLink Raised if a link to the topic does not exist.
       */
      abstract unlink(
        linkTo: TopicPrx | null,
        current: Ice.Current
      ): Ice.OperationResult<void>;

      /**
       * Retrieve information on the current links.
       *
       * @return A sequence of LinkInfo objects.
       */
      abstract getLinkInfoSeq(
        current: Ice.Current
      ): Ice.OperationResult<LinkInfoSeq>;

      /**
       * Retrieve the list of subscribers for this topic.
       *
       * @return The sequence of Ice identities for the subscriber objects.
       */
      abstract getSubscribers(
        current: Ice.Current
      ): Ice.OperationResult<Ice.IdentitySeq>;

      /**
       * Destroy the topic.
       */
      abstract destroy(current: Ice.Current): Ice.OperationResult<void>;
    }

    /**
     * Publishers publish information on a particular topic. A topic
     * logically represents a type.
     *
     * @see TopicManager
     */
    class TopicPrx extends Ice.ObjectPrx {
      /**
       * Get the name of this topic.
       *
       * @return The name of the topic.
       *
       * @see TopicManager#create
       */
      getName(ctx?: Ice.Context): Ice.AsyncResult<string>;

      /**
       * Get a proxy to a publisher object for this topic. To publish
       * data to a topic, the publisher calls {@link Topic#getPublisher} and then
       * casts to the topic type. An unchecked cast must be used on this
       * proxy. If a replicated IceStorm deployment is used this call
       * may return a replicated proxy.
       *
       * @return A proxy to publish data on this topic.
       */
      getPublisher(ctx?: Ice.Context): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Get a non-replicated proxy to a publisher object for this
       * topic. To publish data to a topic, the publisher calls
       * {@link Topic#getPublisher} and then casts to the topic type. An unchecked
       * cast must be used on this proxy.
       *
       * @return A proxy to publish data on this topic.
       */
      getNonReplicatedPublisher(
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Subscribe with the given <tt>qos</tt> to this topic.  A
       * per-subscriber publisher object is returned.
       *
       * @param theQoS The quality of service parameters for this
       * subscription.
       *
       * @param subscriber The subscriber's proxy.
       *
       * @return The per-subscriber publisher object.
       *
       * @throws AlreadySubscribed Raised if the subscriber object is
       * already subscribed.
       *
       * @throws InvalidSubscriber Raised if the subscriber object is null.
       *
       * @throws BadQoS Raised if the requested quality of service
       * is unavailable or invalid.
       *
       * @see #unsubscribe
       */
      subscribeAndGetPublisher(
        theQoS: QoS,
        subscriber: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.ObjectPrx | null>;

      /**
       * Unsubscribe the given <tt>subscriber</tt>.
       *
       * @param subscriber The proxy of an existing subscriber.
       *
       * @see #subscribeAndGetPublisher
       */
      unsubscribe(
        subscriber: Ice.ObjectPrx | null,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Create a link to the given topic. All events originating
       * on this topic will also be sent to <tt>linkTo</tt>.
       *
       * @param linkTo The topic to link to.
       *
       * @param cost The cost to the linked topic.
       *
       * @throws LinkExists Raised if a link to the same topic already
       * exists.
       */
      link(
        linkTo: TopicPrx | null,
        cost: number,
        ctx?: Ice.Context
      ): Ice.AsyncResult<void>;

      /**
       * Destroy the link from this topic to the given topic <tt>linkTo</tt>.
       *
       * @param linkTo The topic to destroy the link to.
       *
       * @throws NoSuchLink Raised if a link to the topic does not exist.
       */
      unlink(linkTo: TopicPrx | null, ctx?: Ice.Context): Ice.AsyncResult<void>;

      /**
       * Retrieve information on the current links.
       *
       * @return A sequence of LinkInfo objects.
       */
      getLinkInfoSeq(ctx?: Ice.Context): Ice.AsyncResult<LinkInfoSeq>;

      /**
       * Retrieve the list of subscribers for this topic.
       *
       * @return The sequence of Ice identities for the subscriber objects.
       */
      getSubscribers(ctx?: Ice.Context): Ice.AsyncResult<Ice.IdentitySeq>;

      /**
       * Destroy the topic.
       */
      destroy(ctx?: Ice.Context): Ice.AsyncResult<void>;
    }

    /**
     * Mapping of topic name to topic proxy.
     */
    type TopicDict = Map<string, TopicPrx | null>;

    /**
     * This exception indicates that an attempt was made to create a topic
     * that already exists.
     */
    class TopicExists extends Ice.UserException {
      constructor(name?: string);

      name: string;
    }

    /**
     * This exception indicates that an attempt was made to retrieve a
     * topic that does not exist.
     */
    class NoSuchTopic extends Ice.UserException {
      constructor(name?: string);

      name: string;
    }

    /**
     * A topic manager manages topics, and subscribers to topics.
     *
     * @see Topic
     */
    abstract class TopicManager extends Ice.Object {
      /**
       * Create a new topic. The topic name must be unique, otherwise
       * {@link TopicExists} is raised.
       *
       * @param name The name of the topic.
       *
       * @return A proxy to the topic instance.
       *
       * @throws TopicExists Raised if a topic with the same name already
       * exists.
       */
      abstract create(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<TopicPrx | null>;

      /**
       * Retrieve a topic by name.
       *
       * @param name The name of the topic.
       *
       * @return A proxy to the topic instance.
       *
       * @throws NoSuchTopic Raised if the topic does not exist.
       */
      abstract retrieve(
        name: string,
        current: Ice.Current
      ): Ice.OperationResult<TopicPrx | null>;

      /**
       * Retrieve all topics managed by this topic manager.
       *
       * @return A dictionary of string, topic proxy pairs.
       */
      abstract retrieveAll(
        current: Ice.Current
      ): Ice.OperationResult<TopicDict>;

      /**
       * Returns the checksums for the IceStorm Slice definitions.
       *
       * @return A dictionary mapping Slice type ids to their checksums.
       */
      abstract getSliceChecksums(
        current: Ice.Current
      ): Ice.OperationResult<Ice.SliceChecksumDict>;
    }

    /**
     * A topic manager manages topics, and subscribers to topics.
     *
     * @see Topic
     */
    class TopicManagerPrx extends Ice.ObjectPrx {
      /**
       * Create a new topic. The topic name must be unique, otherwise
       * {@link TopicExists} is raised.
       *
       * @param name The name of the topic.
       *
       * @return A proxy to the topic instance.
       *
       * @throws TopicExists Raised if a topic with the same name already
       * exists.
       */
      create(name: string, ctx?: Ice.Context): Ice.AsyncResult<TopicPrx | null>;

      /**
       * Retrieve a topic by name.
       *
       * @param name The name of the topic.
       *
       * @return A proxy to the topic instance.
       *
       * @throws NoSuchTopic Raised if the topic does not exist.
       */
      retrieve(
        name: string,
        ctx?: Ice.Context
      ): Ice.AsyncResult<TopicPrx | null>;

      /**
       * Retrieve all topics managed by this topic manager.
       *
       * @return A dictionary of string, topic proxy pairs.
       */
      retrieveAll(ctx?: Ice.Context): Ice.AsyncResult<TopicDict>;

      /**
       * Returns the checksums for the IceStorm Slice definitions.
       *
       * @return A dictionary mapping Slice type ids to their checksums.
       */
      getSliceChecksums(
        ctx?: Ice.Context
      ): Ice.AsyncResult<Ice.SliceChecksumDict>;
    }

    /**
     * This inferface is advertised by the IceStorm service through the
     * Ice object with the identity \`IceStorm/Finder'. This allows clients
     * to retrieve the topic manager with just the endpoint information of
     * the IceStorm service.
     */
    abstract class Finder extends Ice.Object {
      /**
       * Get the topic manager proxy. The proxy might point to several
       * replicas.
       *
       * @return The topic manager proxy.
       */
      abstract getTopicManager(
        current: Ice.Current
      ): Ice.OperationResult<TopicManagerPrx | null>;
    }

    /**
     * This inferface is advertised by the IceStorm service through the
     * Ice object with the identity \`IceStorm/Finder'. This allows clients
     * to retrieve the topic manager with just the endpoint information of
     * the IceStorm service.
     */
    class FinderPrx extends Ice.ObjectPrx {
      /**
       * Get the topic manager proxy. The proxy might point to several
       * replicas.
       *
       * @return The topic manager proxy.
       */
      getTopicManager(
        ctx?: Ice.Context
      ): Ice.AsyncResult<TopicManagerPrx | null>;
    }
  }
}
export { IceStorm } from \\"./IceStorm.ns\\";
"
`;

exports[`generate typings built-in slices 69`] = `
"import { Ice } from \\"ice\\";
import { IceMX } from \\"../Ice/Metrics\\";

declare module \\"../IceMX.ns\\" {
  namespace IceMX {
    /**
     * Provides information on IceStorm topics.
     */
    class TopicMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        published?: Ice.Long,
        forwarded?: Ice.Long
      );

      /**
       * Number of events published on the topic by publishers.
       */
      published: Ice.Long;

      /**
       * Number of events forwarded on the topic by IceStorm topic links.
       */
      forwarded: Ice.Long;
    }

    /**
     * Provides information on IceStorm subscribers.
     */
    class SubscriberMetrics extends Metrics {
      constructor(
        id?: string,
        total?: Ice.Long,
        current?: number,
        totalLifetime?: Ice.Long,
        failures?: number,
        queued?: number,
        outstanding?: number,
        delivered?: Ice.Long
      );

      /**
       * Number of queued events.
       */
      queued: number;

      /**
       * Number of outstanding events.
       */
      outstanding: number;

      /**
       * Number of forwarded events.
       */
      delivered: Ice.Long;
    }
  }
}
export { IceMX } from \\"../IceMX.ns\\";
"
`;

exports[`generate typings module shadowing 1`] = `
"import { Ice } from \\"ice\\";

declare module \\"./A.ns\\" {
  namespace A { class SomeClass extends Ice.Value {} }
}
export { A } from \\"./A.ns\\";
"
`;

exports[`generate typings module shadowing 2`] = `
"import { Ice } from \\"ice\\";
import { A } from \\"A\\";

import _A = A;

declare module \\"./B.ns\\" {
  namespace B { namespace A { class Child extends _A.SomeClass {} } }
}
export { B } from \\"./B.ns\\";
"
`;

exports[`generate typings module shadowing 3`] = `
"import { Ice } from \\"ice\\";
import { A } from \\"A\\";

import _A = A;

declare module \\"./B.ns\\" {
  namespace B { class Child extends _A.SomeClass {} }
}
export { B } from \\"./B.ns\\";
"
`;
